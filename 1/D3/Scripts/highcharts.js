/*
 Highcharts JS v4.0.3 (2014-07-03)

 (c) 2009-2014 Torstein Honsi

 License: www.highcharts.com/license
*/
(function () { function u(a, b) { var c; a || (a = {}); for (c in b) a[c] = b[c]; return a } function A() { var a, b = arguments, c, d = {}, e = function (a, b) { var c, d; "object" !== typeof a && (a = {}); for (d in b) b.hasOwnProperty(d) && ((c = b[d]) && "object" === typeof c && "[object Array]" !== Object.prototype.toString.call(c) && "renderTo" !== d && "number" !== typeof c.nodeType ? a[d] = e(a[d] || {}, c) : a[d] = b[d]); return a }; !0 === b[0] && (d = b[1], b = Array.prototype.slice.call(b, 2)); c = b.length; for (a = 0; a < c; a++) d = e(d, b[a]); return d } function C(a, b) { return parseInt(a, b || 10) } function Ga(a) { return "string" === typeof a } function ea(a) { return a && "object" === typeof a } function Ma(a) { return "[object Array]" === Object.prototype.toString.call(a) } function ja(a) { return "number" === typeof a } function za(a) { return W.log(a) / W.LN10 } function ka(a) { return W.pow(10, a) } function la(a, b) { for (var c = a.length; c--;) if (a[c] === b) { a.splice(c, 1); break } } function v(a) { return a !== w && null !== a } function R(a, b, c) { var d, e; if (Ga(b)) v(c) ? a.setAttribute(b, c) : a && a.getAttribute && (e = a.getAttribute(b)); else if (v(b) && ea(b)) for (d in b) a.setAttribute(d, b[d]); return e } function ra(a) { return Ma(a) ? a : [a] } function s() { var a = arguments, b, c, d = a.length; for (b = 0; b < d; b++) if (c = a[b], c !== w && null !== c) return c } function D(a, b) { Aa && !ca && b && b.opacity !== w && (b.filter = "alpha(opacity\x3d" + 100 * b.opacity + ")"); u(a.style, b) } function aa(a, b, c, d, e) { a = z.createElement(a); b && u(a, b); e && D(a, { padding: 0, border: V, margin: 0 }); c && D(a, c); d && d.appendChild(a); return a } function ma(a, b) { var c = function () { return w }; c.prototype = new a; u(c.prototype, b); return c } function Ha(a, b, c, d) { var e = K.lang; a = +a || 0; var f = -1 === b ? (a.toString().split(".")[1] || "").length : isNaN(b = S(b)) ? 2 : b; b = void 0 === c ? e.decimalPoint : c; d = void 0 === d ? e.thousandsSep : d; e = 0 > a ? "-" : ""; c = String(C(a = S(a).toFixed(f))); var g = 3 < c.length ? c.length % 3 : 0; return e + (g ? c.substr(0, g) + d : "") + c.substr(g).replace(/(\d{3})(?=\d)/g, "$1" + d) + (f ? b + S(a - c).toFixed(f).slice(2) : "") } function Ia(a, b) { return Array((b || 2) + 1 - String(a).length).join(0) + a } function Na(a, b, c) { var d = a[b]; a[b] = function () { var a = Array.prototype.slice.call(arguments); a.unshift(d); return c.apply(this, a) } } function Ja(a, b) { for (var c = "{", d = !1, e, f, g, h, k, l = []; -1 !== (c = a.indexOf(c)) ;) { e = a.slice(0, c); if (d) { f = e.split(":"); g = f.shift().split("."); k = g.length; e = b; for (h = 0; h < k; h++) e = e[g[h]]; f.length && (f = f.join(":"), g = /\.([0-9])/, h = K.lang, k = void 0, /f$/.test(f) ? (k = (k = f.match(g)) ? k[1] : -1, null !== e && (e = Ha(e, k, h.decimalPoint, -1 < f.indexOf(",") ? h.thousandsSep : ""))) : e = fb(f, e)) } l.push(e); a = a.slice(c + 1); c = (d = !d) ? "}" : "{" } l.push(a); return l.join("") } function rb(a) { return W.pow(10, U(W.log(a) / W.LN10)) } function sb(a, b, c, d) { var e; c = s(c, 1); e = a / c; b || (b = [1, 2, 2.5, 5, 10], d && !1 === d.allowDecimals && (1 === c ? b = [1, 2, 5, 10] : 0.1 >= c && (b = [1 / c]))); for (d = 0; d < b.length && !(a = b[d], e <= (b[d] + (b[d + 1] || b[d])) / 2) ; d++); return a * c } function tb(a, b) { var c = a.length, d, e; for (e = 0; e < c; e++) a[e].ss_i = e; a.sort(function (a, c) { d = b(a, c); return 0 === d ? a.ss_i - c.ss_i : d }); for (e = 0; e < c; e++) delete a[e].ss_i } function Oa(a) { for (var b = a.length, c = a[0]; b--;) a[b] < c && (c = a[b]); return c } function Ba(a) { for (var b = a.length, c = a[0]; b--;) a[b] > c && (c = a[b]); return c } function Pa(a, b) { for (var c in a) a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c] } function Qa(a) { gb || (gb = aa(Ka)); a && gb.appendChild(a); gb.innerHTML = "" } function fa(a) { return parseFloat(a.toPrecision(14)) } function Ra(a, b) { va = s(a, b.animation) } function Mb() { var a = K.global.useUTC, b = a ? "getUTC" : "get", c = a ? "setUTC" : "set"; Sa = 6E4 * (a && K.global.timezoneOffset || 0); hb = a ? Date.UTC : function (a, b, c, g, h, k) { return (new Date(a, b, s(c, 1), s(g, 0), s(h, 0), s(k, 0))).getTime() }; ub = b + "Minutes"; vb = b + "Hours"; wb = b + "Day"; Xa = b + "Date"; ib = b + "Month"; jb = b + "FullYear"; Nb = c + "Minutes"; Ob = c + "Hours"; xb = c + "Date"; Pb = c + "Month"; Qb = c + "FullYear" } function O() { } function Ta(a, b, c, d) { this.axis = a; this.pos = b; this.type = c || ""; this.isNew = !0; c || d || this.addLabel() } function na() { this.init.apply(this, arguments) } function Ya() { this.init.apply(this, arguments) } function Rb(a, b, c, d, e) { var f = a.chart.inverted; this.axis = a; this.isNegative = c; this.options = b; this.x = d; this.total = null; this.points = {}; this.stack = e; this.alignOptions = { align: b.align || (f ? c ? "left" : "right" : "center"), verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"), y: s(b.y, f ? 4 : c ? 14 : -6), x: s(b.x, f ? c ? -6 : 6 : 0) }; this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center") } var w, z = document, I = window, W = Math, y = W.round, U = W.floor, La = W.ceil, x = W.max, F = W.min, S = W.abs, ba = W.cos, ga = W.sin, oa = W.PI, Ca = 2 * oa / 360, wa = navigator.userAgent, Sb = I.opera, Aa = /msie/i.test(wa) && !Sb, kb = 8 === z.documentMode, yb = /AppleWebKit/.test(wa), Ua = /Firefox/.test(wa), Tb = /(Mobile|Android|Windows Phone)/.test(wa), xa = "http://www.w3.org/2000/svg", ca = !!z.createElementNS && !!z.createElementNS(xa, "svg").createSVGRect, bc = Ua && 4 > parseInt(wa.split("Firefox/")[1], 10), ha = !ca && !Aa && !!z.createElement("canvas").getContext, Za, $a, Ub = {}, zb = 0, gb, K, fb, va, Ab, E, pa, sa = function () { return w }, X = [], ab = 0, Ka = "div", V = "none", cc = /^[0-9]+$/, dc = "stroke-width", hb, Sa, ub, vb, wb, Xa, ib, jb, Nb, Ob, xb, Pb, Qb, M = {}, J, bb = {}; I.Highcharts ? pa(16, !0) : J = I.Highcharts = {}; fb = function (a, b, c) { if (!v(b) || isNaN(b)) return "Invalid date"; a = s(a, "%Y-%m-%d %H:%M:%S"); var d = new Date(b - Sa), e, f = d[vb](), g = d[wb](), h = d[Xa](), k = d[ib](), l = d[jb](), m = K.lang, n = m.weekdays, d = u({ a: n[g].substr(0, 3), A: n[g], d: Ia(h), e: h, b: m.shortMonths[k], B: m.months[k], m: Ia(k + 1), y: l.toString().substr(2, 2), Y: l, H: Ia(f), I: Ia(f % 12 || 12), l: f % 12 || 12, M: Ia(d[ub]()), p: 12 > f ? "AM" : "PM", P: 12 > f ? "am" : "pm", S: Ia(d.getSeconds()), L: Ia(y(b % 1E3), 3) }, J.dateFormats); for (e in d) for (; -1 !== a.indexOf("%" + e) ;) a = a.replace("%" + e, "function" === typeof d[e] ? d[e](b) : d[e]); return c ? a.substr(0, 1).toUpperCase() + a.substr(1) : a }; pa = function (a, b) { var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a; if (b) throw c; I.console && console.log(c) }; E = { millisecond: 1, second: 1E3, minute: 6E4, hour: 36E5, day: 864E5, week: 6048E5, month: 26784E5, year: 31556952E3 }; Ab = { init: function (a, b, c) { b = b || ""; var d = a.shift, e = -1 < b.indexOf("C"), f = e ? 7 : 3, g; b = b.split(" "); c = [].concat(c); var h, k, l = function (a) { for (g = a.length; g--;) "M" === a[g] && a.splice(g + 1, 0, a[g + 1], a[g + 2], a[g + 1], a[g + 2]) }; e && (l(b), l(c)); a.isArea && (h = b.splice(b.length - 6, 6), k = c.splice(c.length - 6, 6)); if (d <= c.length / f && b.length === c.length) for (; d--;) c = [].concat(c).splice(0, f).concat(c); a.shift = 0; if (b.length) for (a = c.length; b.length < a;) d = [].concat(b).splice(b.length - f, f), e && (d[f - 6] = d[f - 2], d[f - 5] = d[f - 1]), b = b.concat(d); h && (b = b.concat(h), c = c.concat(k)); return [b, c] }, step: function (a, b, c, d) { var e = [], f = a.length; if (1 === c) e = d; else if (f === b.length && 1 > c) for (; f--;) d = parseFloat(a[f]), e[f] = isNaN(d) ? a[f] : c * parseFloat(b[f] - d) + d; else e = b; return e } }; (function (a) { I.HighchartsAdapter = I.HighchartsAdapter || a && { init: function (b) { var c = a.fx, d = c.step, e, f = a.Tween, g = f && f.propHooks; e = a.cssHooks.opacity; a.extend(a.easing, { easeOutQuad: function (a, b, c, d, e) { return -d * (b /= e) * (b - 2) + c } }); a.each(["cur", "_default", "width", "height", "opacity"], function (a, b) { var e = d, m; "cur" === b ? e = c.prototype : "_default" === b && f && (e = g[b], b = "set"); (m = e[b]) && (e[b] = function (c) { var d; c = a ? c : this; if ("align" !== c.prop) return d = c.elem, d.attr ? d.attr(c.prop, "cur" === b ? w : c.now) : m.apply(this, arguments) }) }); Na(e, "get", function (a, b, c) { return b.attr ? b.opacity || 0 : a.call(this, b, c) }); e = function (a) { var c = a.elem, d; a.started || (d = b.init(c, c.d, c.toD), a.start = d[0], a.end = d[1], a.started = !0); c.attr("d", b.step(a.start, a.end, a.pos, c.toD)) }; f ? g.d = { set: e } : d.d = e; this.each = Array.prototype.forEach ? function (a, b) { return Array.prototype.forEach.call(a, b) } : function (a, b) { var c, d = a.length; for (c = 0; c < d; c++) if (!1 === b.call(a[c], a[c], c, a)) return c }; a.fn.highcharts = function () { var a = "Chart", b = arguments, c, d; this[0] && (Ga(b[0]) && (a = b[0], b = Array.prototype.slice.call(b, 1)), bb = c = b[0], c !== w && (c.chart = c.chart || {}, c.chart.renderTo = this[0], new J[a](c, b[1]), d = this), c === w && (d = X[R(this[0], "data-highcharts-chart")])); return d } }, getScript: a.getScript, inArray: a.inArray, adapterRun: function (b, c) { return a(b)[c]() }, grep: a.grep, map: function (a, c) { for (var d = [], e = 0, f = a.length; e < f; e++) d[e] = c.call(a[e], a[e], e, a); return d }, offset: function (b) { return a(b).offset() }, addEvent: function (b, c, d) { a(b).bind(c, d) }, removeEvent: function (b, c, d) { var e = z.removeEventListener ? "removeEventListener" : "detachEvent"; z[e] && b && !b[e] && (b[e] = function () { }); a(b).unbind(c, d) }, fireEvent: function (b, c, d, e) { var f = a.Event(c), g = "detached" + c, h; !Aa && d && (delete d.layerX, delete d.layerY, delete d.returnValue); u(f, d); b[c] && (b[g] = b[c], b[c] = null); a.each(["preventDefault", "stopPropagation"], function (a, b) { var c = f[b]; f[b] = function () { try { c.call(f) } catch (a) { "preventDefault" === b && (h = !0) } } }); a(b).trigger(f); b[g] && (b[c] = b[g], b[g] = null); !e || f.isDefaultPrevented() || h || e(f) }, washMouseEvent: function (a) { var c = a.originalEvent || a; c.pageX === w && (c.pageX = a.pageX, c.pageY = a.pageY); return c }, animate: function (b, c, d) { var e = a(b); b.style || (b.style = {}); c.d && (b.toD = c.d, c.d = 1); e.stop(); c.opacity !== w && b.attr && (c.opacity += "px"); e.animate(c, d) }, stop: function (b) { a(b).stop() } } })(I.jQuery); var lb = I.HighchartsAdapter, ia = lb || {}; lb && lb.init.call(lb, Ab); var mb = ia.adapterRun, ec = ia.getScript, Da = ia.inArray, t = ia.each, Bb = ia.grep, fc = ia.offset, Va = ia.map, P = ia.addEvent, Y = ia.removeEvent, N = ia.fireEvent, gc = ia.washMouseEvent, nb = ia.animate, cb = ia.stop, Cb = { enabled: !0, x: 0, y: 15, style: { color: "#606060", cursor: "default", fontSize: "12px" } }; K = { colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #8085e8 #8d4653 #91e8e1".split(" "), symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: "," }, global: { useUTC: !0, canvasToolsURL: "http://code.highcharts.com/4.0.3/modules/canvas-tools.js", VMLRadialGradientURL: "http://code.highcharts.com/4.0.3/gfx/vml-radial-gradient.png" }, chart: { borderColor: "#4572A7", borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: { theme: { zIndex: 20 }, position: { align: "right", x: -10, y: 10 } } }, title: { text: "Chart title", align: "center", margin: 15, style: { color: "#333333", fontSize: "18px" } }, subtitle: { text: "", align: "center", style: { color: "#555555" } }, plotOptions: { line: { allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1E3 }, events: {}, lineWidth: 2, marker: { lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: { hover: { enabled: !0, lineWidthPlus: 1, radiusPlus: 2 }, select: { fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: A(Cb, { align: "center", enabled: !1, formatter: function () { return null === this.y ? "" : Ha(this.y, -1) }, verticalAlign: "bottom", y: 0 }), cropThreshold: 300, pointRange: 0, states: { hover: { lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { marker: {} } }, stickyTracking: !0, turboThreshold: 1E3 } }, labels: { style: { position: "absolute", color: "#3E576F" } }, legend: { enabled: !0, align: "center", layout: "horizontal", labelFormatter: function () { return this.name }, borderColor: "#909090", borderRadius: 0, navigation: { activeColor: "#274b6d", inactiveColor: "#CCC" }, shadow: !1, itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold" }, itemHoverStyle: { color: "#000" }, itemHiddenStyle: { color: "#CCC" }, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "white", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: !0, animation: ca, backgroundColor: "rgba(249, 249, 249, .85)", borderWidth: 1, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, headerFormat: '\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e', pointFormat: '\x3cspan style\x3d"color:{series.color}"\x3e\u25cf\x3c/span\x3e {series.name}: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e', shadow: !0, snap: Tb ? 25 : 10, style: { color: "#333333", cursor: "default", fontSize: "12px", padding: "8px", whiteSpace: "nowrap" } }, credits: { enabled: !0, text: "Highcharts.com", href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#909090", fontSize: "9px" } } }; var da = K.plotOptions, db = da.line; Mb(); var hc = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, ic = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, jc = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, ya = function (a) { var b = [], c, d; (function (a) { a && a.stops ? d = Va(a.stops, function (a) { return ya(a[1]) }) : (c = hc.exec(a)) ? b = [C(c[1]), C(c[2]), C(c[3]), parseFloat(c[4], 10)] : (c = ic.exec(a)) ? b = [C(c[1], 16), C(c[2], 16), C(c[3], 16), 1] : (c = jc.exec(a)) && (b = [C(c[1]), C(c[2]), C(c[3]), 1]) })(a); return { get: function (c) { var f; d ? (f = A(a), f.stops = [].concat(f.stops), t(d, function (a, b) { f.stops[b] = [f.stops[b][0], a.get(c)] })) : f = b && !isNaN(b[0]) ? "rgb" === c ? "rgb(" + b[0] + "," + b[1] + "," + b[2] + ")" : "a" === c ? b[3] : "rgba(" + b.join(",") + ")" : a; return f }, brighten: function (a) { if (d) t(d, function (b) { b.brighten(a) }); else if (ja(a) && 0 !== a) { var c; for (c = 0; 3 > c; c++) b[c] += C(255 * a), 0 > b[c] && (b[c] = 0), 255 < b[c] && (b[c] = 255) } return this }, rgba: b, setOpacity: function (a) { b[3] = a; return this } } }; O.prototype = { opacity: 1, textProps: "fontSize fontWeight fontFamily color lineHeight width textDecoration textShadow HcTextStroke".split(" "), init: function (a, b) { this.element = "span" === b ? aa(b) : z.createElementNS(xa, b); this.renderer = a }, animate: function (a, b, c) { b = s(b, va, !0); cb(this); b ? (b = A(b, {}), c && (b.complete = c), nb(this, a, b)) : (this.attr(a), c && c()); return this }, colorGradient: function (a, b, c) { var d = this.renderer, e, f, g, h, k, l, m, n, p, q, r = []; a.linearGradient ? f = "linearGradient" : a.radialGradient && (f = "radialGradient"); if (f) { g = a[f]; h = d.gradients; l = a.stops; p = c.radialReference; Ma(g) && (a[f] = g = { x1: g[0], y1: g[1], x2: g[2], y2: g[3], gradientUnits: "userSpaceOnUse" }); "radialGradient" === f && p && !v(g.gradientUnits) && (g = A(g, { cx: p[0] - p[2] / 2 + g.cx * p[2], cy: p[1] - p[2] / 2 + g.cy * p[2], r: g.r * p[2], gradientUnits: "userSpaceOnUse" })); for (q in g) "id" !== q && r.push(q, g[q]); for (q in l) r.push(l[q]); r = r.join(","); h[r] ? a = h[r].attr("id") : (g.id = a = "highcharts-" + zb++, h[r] = k = d.createElement(f).attr(g).add(d.defs), k.stops = [], t(l, function (a) { 0 === a[1].indexOf("rgba") ? (e = ya(a[1]), m = e.get("rgb"), n = e.get("a")) : (m = a[1], n = 1); a = d.createElement("stop").attr({ offset: a[0], "stop-color": m, "stop-opacity": n }).add(k); k.stops.push(a) })); c.setAttribute(b, "url(" + d.url + "#" + a + ")") } }, attr: function (a, b) { var c, d, e = this.element, f, g = this, h; "string" === typeof a && b !== w && (c = a, a = {}, a[c] = b); if ("string" === typeof a) g = (this[a + "Getter"] || this._defaultGetter).call(this, a, e); else { for (c in a) d = a[c], h = !1, this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(c) && (f || (this.symbolAttr(a), f = !0), h = !0), !this.rotation || "x" !== c && "y" !== c || (this.doTransform = !0), h || (this[c + "Setter"] || this._defaultSetter).call(this, d, c, e), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, d); this.doTransform && (this.updateTransform(), this.doTransform = !1) } return g }, updateShadows: function (a, b) { for (var c = this.shadows, d = c.length; d--;) c[d].setAttribute(a, "height" === a ? x(b - (c[d].cutHeight || 0), 0) : "d" === a ? this.d : b) }, addClass: function (a) { var b = this.element, c = R(b, "class") || ""; -1 === c.indexOf(a) && R(b, "class", c + " " + a); return this }, symbolAttr: function (a) { var b = this; t("x y r start end width height innerR anchorX anchorY".split(" "), function (c) { b[c] = s(a[c], b[c]) }); b.attr({ d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b) }) }, clip: function (a) { return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : V) }, crisp: function (a) { var b, c = {}, d, e = a.strokeWidth || this.strokeWidth || 0; d = y(e) % 2 / 2; a.x = U(a.x || this.x || 0) + d; a.y = U(a.y || this.y || 0) + d; a.width = U((a.width || this.width || 0) - 2 * d); a.height = U((a.height || this.height || 0) - 2 * d); a.strokeWidth = e; for (b in a) this[b] !== a[b] && (this[b] = c[b] = a[b]); return c }, css: function (a) { var b = this.styles, c = {}, d = this.element, e, f, g = ""; e = !b; a && a.color && (a.fill = a.color); if (b) for (f in a) a[f] !== b[f] && (c[f] = a[f], e = !0); if (e) { e = this.textWidth = a && a.width && "text" === d.nodeName.toLowerCase() && C(a.width); b && (a = u(b, c)); this.styles = a; e && (ha || !ca && this.renderer.forExport) && delete a.width; if (Aa && !ca) D(this.element, a); else { b = function (a, b) { return "-" + b.toLowerCase() }; for (f in a) g += f.replace(/([A-Z])/g, b) + ":" + a[f] + ";"; R(d, "style", g) } e && this.added && this.renderer.buildText(this) } return this }, on: function (a, b) { var c = this, d = c.element; $a && "click" === a ? (d.ontouchstart = function (a) { c.touchEventFired = Date.now(); a.preventDefault(); b.call(d, a) }, d.onclick = function (a) { (-1 === wa.indexOf("Android") || 1100 < Date.now() - (c.touchEventFired || 0)) && b.call(d, a) }) : d["on" + a] = b; return this }, setRadialReference: function (a) { this.element.radialReference = a; return this }, translate: function (a, b) { return this.attr({ translateX: a, translateY: b }) }, invert: function () { this.inverted = !0; this.updateTransform(); return this }, updateTransform: function () { var a = this.translateX || 0, b = this.translateY || 0, c = this.scaleX, d = this.scaleY, e = this.inverted, f = this.rotation, g = this.element; e && (a += this.attr("width"), b += this.attr("height")); a = ["translate(" + a + "," + b + ")"]; e ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + (g.getAttribute("x") || 0) + " " + (g.getAttribute("y") || 0) + ")"); (v(c) || v(d)) && a.push("scale(" + s(c, 1) + " " + s(d, 1) + ")"); a.length && g.setAttribute("transform", a.join(" ")) }, toFront: function () { var a = this.element; a.parentNode.appendChild(a); return this }, align: function (a, b, c) { var d, e, f, g, h = {}; e = this.renderer; f = e.alignedObjects; if (a) { if (this.alignOptions = a, this.alignByTranslate = b, !c || Ga(c)) this.alignTo = d = c || "renderer", la(f, this), f.push(this), c = null } else a = this.alignOptions, b = this.alignByTranslate, d = this.alignTo; c = s(c, e[d], e); d = a.align; e = a.verticalAlign; f = (c.x || 0) + (a.x || 0); g = (c.y || 0) + (a.y || 0); if ("right" === d || "center" === d) f += (c.width - (a.width || 0)) / { right: 1, center: 2 }[d]; h[b ? "translateX" : "x"] = y(f); if ("bottom" === e || "middle" === e) g += (c.height - (a.height || 0)) / ({ bottom: 1, middle: 2 }[e] || 1); h[b ? "translateY" : "y"] = y(g); this[this.placed ? "animate" : "attr"](h); this.placed = !0; this.alignAttr = h; return this }, getBBox: function () { var a = this.bBox, b = this.renderer, c, d, e = this.rotation; c = this.element; var f = this.styles, g = e * Ca; d = this.textStr; var h; if ("" === d || cc.test(d)) h = "num." + d.toString().length + (f ? "|" + f.fontSize + "|" + f.fontFamily : ""); h && (a = b.cache[h]); if (!a) { if (c.namespaceURI === xa || b.forExport) { try { a = c.getBBox ? u({}, c.getBBox()) : { width: c.offsetWidth, height: c.offsetHeight } } catch (k) { } if (!a || 0 > a.width) a = { width: 0, height: 0 } } else a = this.htmlGetBBox(); b.isSVG && (c = a.width, d = a.height, Aa && f && "12px" === f.fontSize && "16.9" === d.toPrecision(3) && (a.height = d = 14), e && (a.width = S(d * ga(g)) + S(c * ba(g)), a.height = S(d * ba(g)) + S(c * ga(g)))); this.bBox = a; h && (b.cache[h] = a) } return a }, show: function (a) { return a && this.element.namespaceURI === xa ? (this.element.removeAttribute("visibility"), this) : this.attr({ visibility: a ? "inherit" : "visible" }) }, hide: function () { return this.attr({ visibility: "hidden" }) }, fadeOut: function (a) { var b = this; b.animate({ opacity: 0 }, { duration: a || 150, complete: function () { b.hide() } }) }, add: function (a) { var b = this.renderer, c = a || b, d = c.element || b.box, e = this.element, f = this.zIndex, g, h; a && (this.parentGroup = a); this.parentInverted = a && a.inverted; void 0 !== this.textStr && b.buildText(this); f && (c.handleZ = !0, f = C(f)); if (c.handleZ) for (a = d.childNodes, g = 0; g < a.length; g++) if (b = a[g], c = R(b, "zIndex"), b !== e && (C(c) > f || !v(f) && v(c))) { d.insertBefore(e, b); h = !0; break } h || d.appendChild(e); this.added = !0; if (this.onAdd) this.onAdd(); return this }, safeRemoveChild: function (a) { var b = a.parentNode; b && b.removeChild(a) }, destroy: function () { var a = this, b = a.element || {}, c = a.shadows, d = a.renderer.isSVG && "SPAN" === b.nodeName && a.parentGroup, e, f; b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null; cb(a); a.clipPath && (a.clipPath = a.clipPath.destroy()); if (a.stops) { for (f = 0; f < a.stops.length; f++) a.stops[f] = a.stops[f].destroy(); a.stops = null } a.safeRemoveChild(b); for (c && t(c, function (b) { a.safeRemoveChild(b) }) ; d && d.div && 0 === d.div.childNodes.length;) b = d.parentGroup, a.safeRemoveChild(d.div), delete d.div, d = b; a.alignTo && la(a.renderer.alignedObjects, a); for (e in a) delete a[e]; return null }, shadow: function (a, b, c) { var d = [], e, f, g = this.element, h, k, l, m; if (a) { k = s(a.width, 3); l = (a.opacity || 0.15) / k; m = this.parentInverted ? "(-1,-1)" : "(" + s(a.offsetX, 1) + ", " + s(a.offsetY, 1) + ")"; for (e = 1; e <= k; e++) f = g.cloneNode(0), h = 2 * k + 1 - 2 * e, R(f, { isShadow: "true", stroke: a.color || "black", "stroke-opacity": l * e, "stroke-width": h, transform: "translate" + m, fill: V }), c && (R(f, "height", x(R(f, "height") - h, 0)), f.cutHeight = h), b ? b.element.appendChild(f) : g.parentNode.insertBefore(f, g), d.push(f); this.shadows = d } return this }, xGetter: function (a) { "circle" === this.element.nodeName && (a = { x: "cx", y: "cy" }[a] || a); return this._defaultGetter(a) }, _defaultGetter: function (a) { a = s(this[a], this.element ? this.element.getAttribute(a) : null, 0); /^[\-0-9\.]+$/.test(a) && (a = parseFloat(a)); return a }, dSetter: function (a, b, c) { a && a.join && (a = a.join(" ")); /(NaN| {2}|^$)/.test(a) && (a = "M 0 0"); c.setAttribute(b, a); this[b] = a }, dashstyleSetter: function (a) { var b; if (a = a && a.toLowerCase()) { a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").replace("solid", 1).split(","); for (b = a.length; b--;) a[b] = C(a[b]) * this["stroke-width"]; a = a.join(","); this.element.setAttribute("stroke-dasharray", a) } }, alignSetter: function (a) { this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[a]) }, opacitySetter: function (a, b, c) { this[b] = a; c.setAttribute(b, a) }, titleSetter: function (a) { var b = this.element.getElementsByTagName("title")[0]; b || (b = z.createElementNS(xa, "title"), this.element.appendChild(b)); b.textContent = a }, textSetter: function (a) { a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this)) }, fillSetter: function (a, b, c) { "string" === typeof a ? c.setAttribute(b, a) : a && this.colorGradient(a, b, c) }, zIndexSetter: function (a, b, c) { c.setAttribute(b, a); this[b] = a }, _defaultSetter: function (a, b, c) { c.setAttribute(b, a) } }; O.prototype.yGetter = O.prototype.xGetter; O.prototype.translateXSetter = O.prototype.translateYSetter = O.prototype.rotationSetter = O.prototype.verticalAlignSetter = O.prototype.scaleXSetter = O.prototype.scaleYSetter = function (a, b) { this[b] = a; this.doTransform = !0 }; O.prototype["stroke-widthSetter"] = O.prototype.strokeSetter = function (a, b, c) { this[b] = a; this.stroke && this["stroke-width"] ? (this.strokeWidth = this["stroke-width"], O.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === b && 0 === a && this.hasStroke && (c.removeAttribute("stroke"), this.hasStroke = !1) }; var ta = function () { this.init.apply(this, arguments) }; ta.prototype = { Element: O, init: function (a, b, c, d, e) { var f = location, g; d = this.createElement("svg").attr({ version: "1.1" }).css(this.getStyle(d)); g = d.element; a.appendChild(g); -1 === a.innerHTML.indexOf("xmlns") && R(g, "xmlns", xa); this.isSVG = !0; this.box = g; this.boxWrapper = d; this.alignedObjects = []; this.url = (Ua || yb) && z.getElementsByTagName("base").length ? f.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : ""; this.createElement("desc").add().element.appendChild(z.createTextNode("Created with Highcharts 4.0.3")); this.defs = this.createElement("defs").add(); this.forExport = e; this.gradients = {}; this.cache = {}; this.setSize(b, c, !1); var h; Ua && a.getBoundingClientRect && (this.subPixelFix = b = function () { D(a, { left: 0, top: 0 }); h = a.getBoundingClientRect(); D(a, { left: La(h.left) - h.left + "px", top: La(h.top) - h.top + "px" }) }, b(), P(I, "resize", b)) }, getStyle: function (a) { return this.style = u({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, a) }, isHidden: function () { return !this.boxWrapper.getBBox().width }, destroy: function () { var a = this.defs; this.box = null; this.boxWrapper = this.boxWrapper.destroy(); Pa(this.gradients || {}); this.gradients = null; a && (this.defs = a.destroy()); this.subPixelFix && Y(I, "resize", this.subPixelFix); return this.alignedObjects = null }, createElement: function (a) { var b = new this.Element; b.init(this, a); return b }, draw: function () { }, buildText: function (a) { for (var b = a.element, c = this, d = c.forExport, e = s(a.textStr, "").toString(), f = -1 !== e.indexOf("\x3c"), g = b.childNodes, h, k, l = R(b, "x"), m = a.styles, n = a.textWidth, p = m && m.lineHeight, q = m && m.HcTextStroke, r = g.length, Z = function (a) { return p ? C(p) : c.fontMetrics(/(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : m && m.fontSize || c.style.fontSize || 12, a).h }; r--;) b.removeChild(g[r]); f || q || -1 !== e.indexOf(" ") ? (h = /<.*style="([^"]+)".*>/, k = /<.*href="(http[^"]+)".*>/, n && !a.added && this.box.appendChild(b), e = f ? e.replace(/<(b|strong)>/g, '\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g, '\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g, "\x3cspan").replace(/<\/(b|strong|i|em|a)>/g, "\x3c/span\x3e").split(/<br.*?>/g) : [e], "" === e[e.length - 1] && e.pop(), t(e, function (e, f) { var g, q = 0; e = e.replace(/<span/g, "|||\x3cspan").replace(/<\/span>/g, "\x3c/span\x3e|||"); g = e.split("|||"); t(g, function (e) { if ("" !== e || 1 === g.length) { var p = {}, r = z.createElementNS(xa, "tspan"), s; h.test(e) && (s = e.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), R(r, "style", s)); k.test(e) && !d && (R(r, "onclick", 'location.href\x3d"' + e.match(k)[1] + '"'), D(r, { cursor: "pointer" })); e = (e.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "\x3c").replace(/&gt;/g, "\x3e"); if (" " !== e) { r.appendChild(z.createTextNode(e)); q ? p.dx = 0 : f && null !== l && (p.x = l); R(r, p); b.appendChild(r); !q && f && (!ca && d && D(r, { display: "block" }), R(r, "dy", Z(r))); if (n) { e = e.replace(/([^\^])-/g, "$1- ").split(" "); for (var p = 1 < g.length || 1 < e.length && "nowrap" !== m.whiteSpace, t, H, v = m.HcHeight, x = [], w = Z(r), Wb = 1; p && (e.length || x.length) ;) delete a.bBox, t = a.getBBox(), H = t.width, !ca && c.forExport && (H = c.measureSpanWidth(r.firstChild.data, a.styles)), (t = H > n) && 1 !== e.length ? (r.removeChild(r.firstChild), x.unshift(e.pop())) : (e = x, x = [], e.length && (Wb++, v && Wb * w > v ? (e = ["..."], a.attr("title", a.textStr)) : (r = z.createElementNS(xa, "tspan"), R(r, { dy: w, x: l }), s && R(r, "style", s), b.appendChild(r))), H > n && (n = H)), e.length && r.appendChild(z.createTextNode(e.join(" ").replace(/- /g, "-"))) } q++ } } }) })) : b.appendChild(z.createTextNode(e)) }, button: function (a, b, c, d, e, f, g, h, k) { var l = this.label(a, b, c, k, null, null, null, null, "button"), m = 0, n, p, q, r, s, t; a = { x1: 0, y1: 0, x2: 0, y2: 1 }; e = A({ "stroke-width": 1, stroke: "#CCCCCC", fill: { linearGradient: a, stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]] }, r: 2, padding: 5, style: { color: "black" } }, e); q = e.style; delete e.style; f = A(e, { stroke: "#68A", fill: { linearGradient: a, stops: [[0, "#FFF"], [1, "#ACF"]] } }, f); r = f.style; delete f.style; g = A(e, { stroke: "#68A", fill: { linearGradient: a, stops: [[0, "#9BD"], [1, "#CDF"]] } }, g); s = g.style; delete g.style; h = A(e, { style: { color: "#CCC" } }, h); t = h.style; delete h.style; P(l.element, Aa ? "mouseover" : "mouseenter", function () { 3 !== m && l.attr(f).css(r) }); P(l.element, Aa ? "mouseout" : "mouseleave", function () { 3 !== m && (n = [e, f, g][m], p = [q, r, s][m], l.attr(n).css(p)) }); l.setState = function (a) { (l.state = m = a) ? 2 === a ? l.attr(g).css(s) : 3 === a && l.attr(h).css(t) : l.attr(e).css(q) }; return l.on("click", function () { 3 !== m && d.call(l) }).attr(e).css(u({ cursor: "default" }, q)) }, crispLine: function (a, b) { a[1] === a[4] && (a[1] = a[4] = y(a[1]) - b % 2 / 2); a[2] === a[5] && (a[2] = a[5] = y(a[2]) + b % 2 / 2); return a }, path: function (a) { var b = { fill: V }; Ma(a) ? b.d = a : ea(a) && u(b, a); return this.createElement("path").attr(b) }, circle: function (a, b, c) { a = ea(a) ? a : { x: a, y: b, r: c }; b = this.createElement("circle"); b.xSetter = function (a) { this.element.setAttribute("cx", a) }; b.ySetter = function (a) { this.element.setAttribute("cy", a) }; return b.attr(a) }, arc: function (a, b, c, d, e, f) { ea(a) && (b = a.y, c = a.r, d = a.innerR, e = a.start, f = a.end, a = a.x); a = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, { innerR: d || 0, start: e || 0, end: f || 0 }); a.r = c; return a }, rect: function (a, b, c, d, e, f) { e = ea(a) ? a.r : e; var g = this.createElement("rect"); a = ea(a) ? a : a === w ? {} : { x: a, y: b, width: x(c, 0), height: x(d, 0) }; f !== w && (a.strokeWidth = f, a = g.crisp(a)); e && (a.r = e); g.rSetter = function (a) { R(this.element, { rx: a, ry: a }) }; return g.attr(a) }, setSize: function (a, b, c) { var d = this.alignedObjects, e = d.length; this.width = a; this.height = b; for (this.boxWrapper[s(c, !0) ? "animate" : "attr"]({ width: a, height: b }) ; e--;) d[e].align() }, g: function (a) { var b = this.createElement("g"); return v(a) ? b.attr({ "class": "highcharts-" + a }) : b }, image: function (a, b, c, d, e) { var f = { preserveAspectRatio: V }; 1 < arguments.length && u(f, { x: b, y: c, width: d, height: e }); f = this.createElement("image").attr(f); f.element.setAttributeNS ? f.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : f.element.setAttribute("hc-svg-href", a); return f }, symbol: function (a, b, c, d, e, f) { var g, h = this.symbols[a], h = h && h(y(b), y(c), d, e, f), k = /^url\((.*?)\)$/, l, m; h ? (g = this.path(h), u(g, { symbolName: a, x: b, y: c, width: d, height: e }), f && u(g, f)) : k.test(a) && (m = function (a, b) { a.element && (a.attr({ width: b[0], height: b[1] }), a.alignByTranslate || a.translate(y((d - b[0]) / 2), y((e - b[1]) / 2))) }, l = a.match(k)[1], a = Ub[l], g = this.image(l).attr({ x: b, y: c }), g.isImg = !0, a ? m(g, a) : (g.attr({ width: 0, height: 0 }), aa("img", { onload: function () { m(g, Ub[l] = [this.width, this.height]) }, src: l }))); return g }, symbols: { circle: function (a, b, c, d) { var e = 0.166 * c; return ["M", a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"] }, square: function (a, b, c, d) { return ["M", a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z"] }, triangle: function (a, b, c, d) { return ["M", a + c / 2, b, "L", a + c, b + d, a, b + d, "Z"] }, "triangle-down": function (a, b, c, d) { return ["M", a, b, "L", a + c, b, a + c / 2, b + d, "Z"] }, diamond: function (a, b, c, d) { return ["M", a + c / 2, b, "L", a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"] }, arc: function (a, b, c, d, e) { var f = e.start; c = e.r || c || d; var g = e.end - 0.001; d = e.innerR; var h = e.open, k = ba(f), l = ga(f), m = ba(g), g = ga(g); e = e.end - f < oa ? 0 : 1; return ["M", a + c * k, b + c * l, "A", c, c, 0, e, 1, a + c * m, b + c * g, h ? "M" : "L", a + d * m, b + d * g, "A", d, d, 0, e, 0, a + d * k, b + d * l, h ? "" : "Z"] }, callout: function (a, b, c, d, e) { var f = F(e && e.r || 0, c, d), g = f + 6, h = e && e.anchorX, k = e && e.anchorY; e = y(e.strokeWidth || 0) % 2 / 2; a += e; b += e; e = ["M", a + f, b, "L", a + c - f, b, "C", a + c, b, a + c, b, a + c, b + f, "L", a + c, b + d - f, "C", a + c, b + d, a + c, b + d, a + c - f, b + d, "L", a + f, b + d, "C", a, b + d, a, b + d, a, b + d - f, "L", a, b + f, "C", a, b, a, b, a + f, b]; h && h > c && k > b + g && k < b + d - g ? e.splice(13, 3, "L", a + c, k - 6, a + c + 6, k, a + c, k + 6, a + c, b + d - f) : h && 0 > h && k > b + g && k < b + d - g ? e.splice(33, 3, "L", a, k + 6, a - 6, k, a, k - 6, a, b + f) : k && k > d && h > a + g && h < a + c - g ? e.splice(23, 3, "L", h + 6, b + d, h, b + d + 6, h - 6, b + d, a + f, b + d) : k && 0 > k && h > a + g && h < a + c - g && e.splice(3, 3, "L", h - 6, b, h, b - 6, h + 6, b, c - f, b); return e } }, clipRect: function (a, b, c, d) { var e = "highcharts-" + zb++, f = this.createElement("clipPath").attr({ id: e }).add(this.defs); a = this.rect(a, b, c, d, 0).add(f); a.id = e; a.clipPath = f; return a }, text: function (a, b, c, d) { var e = ha || !ca && this.forExport, f = {}; if (d && !this.forExport) return this.html(a, b, c); f.x = Math.round(b || 0); c && (f.y = Math.round(c)); if (a || 0 === a) f.text = a; a = this.createElement("text").attr(f); e && a.css({ position: "absolute" }); d || (a.xSetter = function (a, b, c) { var d = c.getElementsByTagName("tspan"), e, f = c.getAttribute(b), p; for (p = 0; p < d.length; p++) e = d[p], e.getAttribute(b) === f && e.setAttribute(b, a); c.setAttribute(b, a) }); return a }, fontMetrics: function (a, b) { a = a || this.style.fontSize; b && I.getComputedStyle && (b = b.element || b, a = I.getComputedStyle(b, "").fontSize); a = /px/.test(a) ? C(a) : /em/.test(a) ? 12 * parseFloat(a) : 12; var c = 24 > a ? a + 4 : y(1.2 * a), d = y(0.8 * c); return { h: c, b: d, f: a } }, label: function (a, b, c, d, e, f, g, h, k) { function l() { var a, b; a = r.element.style; H = (void 0 === x || void 0 === Db || q.styles.textAlign) && r.textStr && r.getBBox(); q.width = (x || H.width || 0) + 2 * G + ob; q.height = (Db || H.height || 0) + 2 * G; T = G + p.fontMetrics(a && a.fontSize, r).b; C && (s || (a = y(-L * G), b = h ? -T : 0, q.box = s = d ? p.symbol(d, a, b, q.width, q.height, B) : p.rect(a, b, q.width, q.height, 0, B[dc]), s.attr("fill", V).add(q)), s.isImg || s.attr(u({ width: y(q.width), height: y(q.height) }, B)), B = null) } function m() { var a = q.styles, a = a && a.textAlign, b = ob + G * (1 - L), c; c = h ? 0 : T; v(x) && H && ("center" === a || "right" === a) && (b += { center: 0.5, right: 1 }[a] * (x - H.width)); if (b !== r.x || c !== r.y) r.attr("x", b), c !== w && r.attr("y", c); r.x = b; r.y = c } function n(a, b) { s ? s.attr(a, b) : B[a] = b } var p = this, q = p.g(k), r = p.text("", 0, 0, g).attr({ zIndex: 1 }), s, H, L = 0, G = 3, ob = 0, x, Db, Eb, z, Vb = 0, B = {}, T, C; q.onAdd = function () { r.add(q); q.attr({ text: a || "", x: b, y: c }); s && v(e) && q.attr({ anchorX: e, anchorY: f }) }; q.widthSetter = function (a) { x = a }; q.heightSetter = function (a) { Db = a }; q.paddingSetter = function (a) { v(a) && a !== G && (G = a, m()) }; q.paddingLeftSetter = function (a) { v(a) && a !== ob && (ob = a, m()) }; q.alignSetter = function (a) { L = { left: 0, center: 0.5, right: 1 }[a] }; q.textSetter = function (a) { a !== w && r.textSetter(a); l(); m() }; q["stroke-widthSetter"] = function (a, b) { a && (C = !0); Vb = a % 2 / 2; n(b, a) }; q.strokeSetter = q.fillSetter = q.rSetter = function (a, b) { "fill" === b && a && (C = !0); n(b, a) }; q.anchorXSetter = function (a, b) { e = a; n(b, a + Vb - Eb) }; q.anchorYSetter = function (a, b) { f = a; n(b, a - z) }; q.xSetter = function (a) { q.x = a; L && (a -= L * ((x || H.width) + G)); Eb = y(a); q.attr("translateX", Eb) }; q.ySetter = function (a) { z = q.y = y(a); q.attr("translateY", z) }; var F = q.css; return u(q, { css: function (a) { if (a) { var b = {}; a = A(a); t(q.textProps, function (c) { a[c] !== w && (b[c] = a[c], delete a[c]) }); r.css(b) } return F.call(q, a) }, getBBox: function () { return { width: H.width + 2 * G, height: H.height + 2 * G, x: H.x - G, y: H.y - G } }, shadow: function (a) { s && s.shadow(a); return q }, destroy: function () { Y(q.element, "mouseenter"); Y(q.element, "mouseleave"); r && (r = r.destroy()); s && (s = s.destroy()); O.prototype.destroy.call(q); q = p = l = m = n = null } }) } }; Za = ta; u(O.prototype, { htmlCss: function (a) { var b = this.element; if (b = a && "SPAN" === b.tagName && a.width) delete a.width, this.textWidth = b, this.updateTransform(); this.styles = u(this.styles, a); D(this.element, a); return this }, htmlGetBBox: function () { var a = this.element, b = this.bBox; b || ("text" === a.nodeName && (a.style.position = "absolute"), b = this.bBox = { x: a.offsetLeft, y: a.offsetTop, width: a.offsetWidth, height: a.offsetHeight }); return b }, htmlUpdateTransform: function () { if (this.added) { var a = this.renderer, b = this.element, c = this.translateX || 0, d = this.translateY || 0, e = this.x || 0, f = this.y || 0, g = this.textAlign || "left", h = { left: 0, center: 0.5, right: 1 }[g], k = this.shadows; D(b, { marginLeft: c, marginTop: d }); k && t(k, function (a) { D(a, { marginLeft: c + 1, marginTop: d + 1 }) }); this.inverted && t(b.childNodes, function (c) { a.invertChild(c, b) }); if ("SPAN" === b.tagName) { var l = this.rotation, m, n = C(this.textWidth), p = [l, g, b.innerHTML, this.textWidth].join(); p !== this.cTT && (m = a.fontMetrics(b.style.fontSize).b, v(l) && this.setSpanRotation(l, h, m), k = s(this.elemWidth, b.offsetWidth), k > n && /[ \-]/.test(b.textContent || b.innerText) && (D(b, { width: n + "px", display: "block", whiteSpace: "normal" }), k = n), this.getSpanCorrection(k, m, h, l, g)); D(b, { left: e + (this.xCorr || 0) + "px", top: f + (this.yCorr || 0) + "px" }); yb && (m = b.offsetHeight); this.cTT = p } } else this.alignOnAdd = !0 }, setSpanRotation: function (a, b, c) { var d = {}, e = Aa ? "-ms-transform" : yb ? "-webkit-transform" : Ua ? "MozTransform" : Sb ? "-o-transform" : ""; d[e] = d.transform = "rotate(" + a + "deg)"; d[e + (Ua ? "Origin" : "-origin")] = d.transformOrigin = 100 * b + "% " + c + "px"; D(this.element, d) }, getSpanCorrection: function (a, b, c) { this.xCorr = -a * c; this.yCorr = -b } }); u(ta.prototype, { html: function (a, b, c) { var d = this.createElement("span"), e = d.element, f = d.renderer; d.textSetter = function (a) { a !== e.innerHTML && delete this.bBox; e.innerHTML = this.textStr = a }; d.xSetter = d.ySetter = d.alignSetter = d.rotationSetter = function (a, b) { "align" === b && (b = "textAlign"); d[b] = a; d.htmlUpdateTransform() }; d.attr({ text: a, x: y(b), y: y(c) }).css({ position: "absolute", whiteSpace: "nowrap", fontFamily: this.style.fontFamily, fontSize: this.style.fontSize }); d.css = d.htmlCss; f.isSVG && (d.add = function (a) { var b, c = f.box.parentNode, l = []; if (this.parentGroup = a) { if (b = a.div, !b) { for (; a;) l.push(a), a = a.parentGroup; t(l.reverse(), function (a) { var d; b = a.div = a.div || aa(Ka, { className: R(a.element, "class") }, { position: "absolute", left: (a.translateX || 0) + "px", top: (a.translateY || 0) + "px" }, b || c); d = b.style; u(a, { translateXSetter: function (b, c) { d.left = b + "px"; a[c] = b; a.doTransform = !0 }, translateYSetter: function (b, c) { d.top = b + "px"; a[c] = b; a.doTransform = !0 }, visibilitySetter: function (a, b) { d[b] = a } }) }) } } else b = c; b.appendChild(e); d.added = !0; d.alignOnAdd && d.htmlUpdateTransform(); return d }); return d } }); var Fb, Ea; if (!ca && !ha) { Ea = { init: function (a, b) { var c = ["\x3c", b, ' filled\x3d"f" stroked\x3d"f"'], d = ["position: ", "absolute", ";"], e = b === Ka; ("shape" === b || e) && d.push("left:0;top:0;width:1px;height:1px;"); d.push("visibility: ", e ? "hidden" : "visible"); c.push(' style\x3d"', d.join(""), '"/\x3e'); b && (c = e || "span" === b || "img" === b ? c.join("") : a.prepVML(c), this.element = aa(c)); this.renderer = a }, add: function (a) { var b = this.renderer, c = this.element, d = b.box, d = a ? a.element || a : d; a && a.inverted && b.invertChild(c, d); d.appendChild(c); this.added = !0; this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform(); if (this.onAdd) this.onAdd(); return this }, updateTransform: O.prototype.htmlUpdateTransform, setSpanRotation: function () { var a = this.rotation, b = ba(a * Ca), c = ga(a * Ca); D(this.element, { filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11\x3d", b, ", M12\x3d", -c, ", M21\x3d", c, ", M22\x3d", b, ", sizingMethod\x3d'auto expand')"].join("") : V }) }, getSpanCorrection: function (a, b, c, d, e) { var f = d ? ba(d * Ca) : 1, g = d ? ga(d * Ca) : 0, h = s(this.elemHeight, this.element.offsetHeight), k; this.xCorr = 0 > f && -a; this.yCorr = 0 > g && -h; k = 0 > f * g; this.xCorr += g * b * (k ? 1 - c : c); this.yCorr -= f * b * (d ? k ? c : 1 - c : 1); e && "left" !== e && (this.xCorr -= a * c * (0 > f ? -1 : 1), d && (this.yCorr -= h * c * (0 > g ? -1 : 1)), D(this.element, { textAlign: e })) }, pathToVML: function (a) { for (var b = a.length, c = []; b--;) ja(a[b]) ? c[b] = y(10 * a[b]) - 5 : "Z" === a[b] ? c[b] = "x" : (c[b] = a[b], !a.isArc || "wa" !== a[b] && "at" !== a[b] || (c[b + 5] === c[b + 7] && (c[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), c[b + 6] === c[b + 8] && (c[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1))); return c.join(" ") || "x" }, clip: function (a) { var b = this, c; a ? (c = a.members, la(c, b), c.push(b), b.destroyClip = function () { la(c, b) }, a = a.getCSS(b)) : (b.destroyClip && b.destroyClip(), a = { clip: kb ? "inherit" : "rect(auto)" }); return b.css(a) }, css: O.prototype.htmlCss, safeRemoveChild: function (a) { a.parentNode && Qa(a) }, destroy: function () { this.destroyClip && this.destroyClip(); return O.prototype.destroy.apply(this) }, on: function (a, b) { this.element["on" + a] = function () { var a = I.event; a.target = a.srcElement; b(a) }; return this }, cutOffPath: function (a, b) { var c; a = a.split(/[ ,]/); c = a.length; if (9 === c || 11 === c) a[c - 4] = a[c - 2] = C(a[c - 2]) - 10 * b; return a.join(" ") }, shadow: function (a, b, c) { var d = [], e, f = this.element, g = this.renderer, h, k = f.style, l, m = f.path, n, p, q, r; m && "string" !== typeof m.value && (m = "x"); p = m; if (a) { q = s(a.width, 3); r = (a.opacity || 0.15) / q; for (e = 1; 3 >= e; e++) n = 2 * q + 1 - 2 * e, c && (p = this.cutOffPath(m.value, n + 0.5)), l = ['\x3cshape isShadow\x3d"true" strokeweight\x3d"', n, '" filled\x3d"false" path\x3d"', p, '" coordsize\x3d"10 10" style\x3d"', f.style.cssText, '" /\x3e'], h = aa(g.prepVML(l), null, { left: C(k.left) + s(a.offsetX, 1), top: C(k.top) + s(a.offsetY, 1) }), c && (h.cutOff = n + 1), l = ['\x3cstroke color\x3d"', a.color || "black", '" opacity\x3d"', r * e, '"/\x3e'], aa(g.prepVML(l), null, null, h), b ? b.element.appendChild(h) : f.parentNode.insertBefore(h, f), d.push(h); this.shadows = d } return this }, updateShadows: sa, setAttr: function (a, b) { kb ? this.element[a] = b : this.element.setAttribute(a, b) }, classSetter: function (a) { this.element.className = a }, dashstyleSetter: function (a, b, c) { (c.getElementsByTagName("stroke")[0] || aa(this.renderer.prepVML(["\x3cstroke/\x3e"]), null, null, c))[b] = a || "solid"; this[b] = a }, dSetter: function (a, b, c) { var d = this.shadows; a = a || []; this.d = a.join && a.join(" "); c.path = a = this.pathToVML(a); if (d) for (c = d.length; c--;) d[c].path = d[c].cutOff ? this.cutOffPath(a, d[c].cutOff) : a; this.setAttr(b, a) }, fillSetter: function (a, b, c) { var d = c.nodeName; "SPAN" === d ? c.style.color = a : "IMG" !== d && (c.filled = a !== V, this.setAttr("fillcolor", this.renderer.color(a, c, b, this))) }, opacitySetter: sa, rotationSetter: function (a, b, c) { c = c.style; this[b] = c[b] = a; c.left = -y(ga(a * Ca) + 1) + "px"; c.top = y(ba(a * Ca)) + "px" }, strokeSetter: function (a, b, c) { this.setAttr("strokecolor", this.renderer.color(a, c, b)) }, "stroke-widthSetter": function (a, b, c) { c.stroked = !!a; this[b] = a; ja(a) && (a += "px"); this.setAttr("strokeweight", a) }, titleSetter: function (a, b) { this.setAttr(b, a) }, visibilitySetter: function (a, b, c) { "inherit" === a && (a = "visible"); this.shadows && t(this.shadows, function (c) { c.style[b] = a }); "DIV" === c.nodeName && (a = "hidden" === a ? "-999em" : 0, kb || (c.style[b] = a ? "visible" : "hidden"), b = "top"); c.style[b] = a }, xSetter: function (a, b, c) { this[b] = a; "x" === b ? b = "left" : "y" === b && (b = "top"); this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a }, zIndexSetter: function (a, b, c) { c.style[b] = a } }; J.VMLElement = Ea = ma(O, Ea); Ea.prototype.ySetter = Ea.prototype.widthSetter = Ea.prototype.heightSetter = Ea.prototype.xSetter; var kc = { Element: Ea, isIE8: -1 < wa.indexOf("MSIE 8.0"), init: function (a, b, c, d) { var e; this.alignedObjects = []; d = this.createElement(Ka).css(u(this.getStyle(d), { position: "relative" })); e = d.element; a.appendChild(d.element); this.isVML = !0; this.box = e; this.boxWrapper = d; this.cache = {}; this.setSize(b, c, !1); if (!z.namespaces.hcv) { z.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"); try { z.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } catch (f) { z.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } } }, isHidden: function () { return !this.box.offsetWidth }, clipRect: function (a, b, c, d) { var e = this.createElement(), f = ea(a); return u(e, { members: [], left: (f ? a.x : a) + 1, top: (f ? a.y : b) + 1, width: (f ? a.width : c) - 1, height: (f ? a.height : d) - 1, getCSS: function (a) { var b = a.element, c = b.nodeName; a = a.inverted; var d = this.top - ("shape" === c ? b.offsetTop : 0), e = this.left, b = e + this.width, f = d + this.height, d = { clip: "rect(" + y(a ? e : d) + "px," + y(a ? f : b) + "px," + y(a ? b : f) + "px," + y(a ? d : e) + "px)" }; !a && kb && "DIV" === c && u(d, { width: b + "px", height: f + "px" }); return d }, updateClipping: function () { t(e.members, function (a) { a.element && a.css(e.getCSS(a)) }) } }) }, color: function (a, b, c, d) { var e = this, f, g = /^rgba/, h, k, l = V; a && a.linearGradient ? k = "gradient" : a && a.radialGradient && (k = "pattern"); if (k) { var m, n, p = a.linearGradient || a.radialGradient, q, r, s, H, L, G = ""; a = a.stops; var x, v = [], w = function () { h = ['\x3cfill colors\x3d"' + v.join(",") + '" opacity\x3d"', s, '" o:opacity2\x3d"', r, '" type\x3d"', k, '" ', G, 'focus\x3d"100%" method\x3d"any" /\x3e']; aa(e.prepVML(h), null, null, b) }; q = a[0]; x = a[a.length - 1]; 0 < q[0] && a.unshift([0, q[1]]); 1 > x[0] && a.push([1, x[1]]); t(a, function (a, b) { g.test(a[1]) ? (f = ya(a[1]), m = f.get("rgb"), n = f.get("a")) : (m = a[1], n = 1); v.push(100 * a[0] + "% " + m); b ? (s = n, H = m) : (r = n, L = m) }); if ("fill" === c) if ("gradient" === k) c = p.x1 || p[0] || 0, a = p.y1 || p[1] || 0, q = p.x2 || p[2] || 0, p = p.y2 || p[3] || 0, G = 'angle\x3d"' + (90 - 180 * W.atan((p - a) / (q - c)) / oa) + '"', w(); else { var l = p.r, u = 2 * l, y = 2 * l, z = p.cx, B = p.cy, T = b.radialReference, A, l = function () { T && (A = d.getBBox(), z += (T[0] - A.x) / A.width - 0.5, B += (T[1] - A.y) / A.height - 0.5, u *= T[2] / A.width, y *= T[2] / A.height); G = 'src\x3d"' + K.global.VMLRadialGradientURL + '" size\x3d"' + u + "," + y + '" origin\x3d"0.5,0.5" position\x3d"' + z + "," + B + '" color2\x3d"' + L + '" '; w() }; d.added ? l() : d.onAdd = l; l = H } else l = m } else g.test(a) && "IMG" !== b.tagName ? (f = ya(a), h = ["\x3c", c, ' opacity\x3d"', f.get("a"), '"/\x3e'], aa(this.prepVML(h), null, null, b), l = f.get("rgb")) : (l = b.getElementsByTagName(c), l.length && (l[0].opacity = 1, l[0].type = "solid"), l = a); return l }, prepVML: function (a) { var b = this.isIE8; a = a.join(""); b ? (a = a.replace("/\x3e", ' xmlns\x3d"urn:schemas-microsoft-com:vml" /\x3e'), a = -1 === a.indexOf('style\x3d"') ? a.replace("/\x3e", ' style\x3d"display:inline-block;behavior:url(#default#VML);" /\x3e') : a.replace('style\x3d"', 'style\x3d"display:inline-block;behavior:url(#default#VML);')) : a = a.replace("\x3c", "\x3chcv:"); return a }, text: ta.prototype.html, path: function (a) { var b = { coordsize: "10 10" }; Ma(a) ? b.d = a : ea(a) && u(b, a); return this.createElement("shape").attr(b) }, circle: function (a, b, c) { var d = this.symbol("circle"); ea(a) && (c = a.r, b = a.y, a = a.x); d.isCircle = !0; d.r = c; return d.attr({ x: a, y: b }) }, g: function (a) { var b; a && (b = { className: "highcharts-" + a, "class": "highcharts-" + a }); return this.createElement(Ka).attr(b) }, image: function (a, b, c, d, e) { var f = this.createElement("img").attr({ src: a }); 1 < arguments.length && f.attr({ x: b, y: c, width: d, height: e }); return f }, createElement: function (a) { return "rect" === a ? this.symbol(a) : ta.prototype.createElement.call(this, a) }, invertChild: function (a, b) { var c = this, d = b.style, e = "IMG" === a.tagName && a.style; D(a, { flip: "x", left: C(d.width) - (e ? C(e.top) : 1), top: C(d.height) - (e ? C(e.left) : 1), rotation: -90 }); t(a.childNodes, function (b) { c.invertChild(b, a) }) }, symbols: { arc: function (a, b, c, d, e) { var f = e.start, g = e.end, h = e.r || c || d; c = e.innerR; d = ba(f); var k = ga(f), l = ba(g), m = ga(g); if (0 === g - f) return ["x"]; f = ["wa", a - h, b - h, a + h, b + h, a + h * d, b + h * k, a + h * l, b + h * m]; e.open && !c && f.push("e", "M", a, b); f.push("at", a - c, b - c, a + c, b + c, a + c * l, b + c * m, a + c * d, b + c * k, "x", "e"); f.isArc = !0; return f }, circle: function (a, b, c, d, e) { e && (c = d = 2 * e.r); e && e.isCircle && (a -= c / 2, b -= d / 2); return ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"] }, rect: function (a, b, c, d, e) { return ta.prototype.symbols[v(e) && e.r ? "callout" : "square"].call(0, a, b, c, d, e) } } }; J.VMLRenderer = Fb = function () { this.init.apply(this, arguments) }; Fb.prototype = A(ta.prototype, kc); Za = Fb } ta.prototype.measureSpanWidth = function (a, b) { var c = z.createElement("span"), d; d = z.createTextNode(a); c.appendChild(d); D(c, b); this.box.appendChild(c); d = c.offsetWidth; Qa(c); return d }; var Gb, Xb; ha && (J.CanVGRenderer = Gb = function () { xa = "http://www.w3.org/1999/xhtml" }, Gb.prototype.symbols = {}, Xb = function () { function a() { var a = b.length, d; for (d = 0; d < a; d++) b[d](); b = [] } var b = []; return { push: function (c, d) { 0 === b.length && ec(d, a); b.push(c) } } }(), Za = Gb); Ta.prototype = { addLabel: function () { var a = this.axis, b = a.options, c = a.chart, d = a.horiz, e = a.categories, f = a.names, g = this.pos, h = b.labels, k = h.rotation, l = a.tickPositions, d = d && e && !h.step && !h.staggerLines && !h.rotation && c.plotWidth / l.length || !d && (c.margin[3] || 0.33 * c.chartWidth), m = g === l[0], n = g === l[l.length - 1], p, f = e ? s(e[g], f[g], g) : g, e = this.label, q = l.info; a.isDatetimeAxis && q && (p = b.dateTimeLabelFormats[q.higherRanks[g] || q.unitName]); this.isFirst = m; this.isLast = n; b = a.labelFormatter.call({ axis: a, chart: c, isFirst: m, isLast: n, dateTimeLabelFormat: p, value: a.isLog ? fa(ka(f)) : f }); g = d && { width: x(1, y(d - 2 * (h.padding || 10))) + "px" }; g = u(g, h.style); v(e) ? e && e.attr({ text: b }).css(g) : (p = { align: a.labelAlign }, ja(k) && (p.rotation = k), d && h.ellipsis && (g.HcHeight = a.len / l.length), this.label = e = v(b) && h.enabled ? c.renderer.text(b, 0, 0, h.useHTML).attr(p).css(g).add(a.labelGroup) : null, a.tickBaseline = c.renderer.fontMetrics(h.style.fontSize, e).b, k && 2 === a.side && (a.tickBaseline *= ba(k * Ca))); this.yOffset = e ? s(h.y, a.tickBaseline + (2 === a.side ? 8 : -(e.getBBox().height / 2))) : 0 }, getLabelSize: function () { var a = this.label, b = this.axis; return a ? a.getBBox()[b.horiz ? "height" : "width"] : 0 }, getLabelSides: function () { var a = this.label.getBBox(), b = this.axis, c = b.horiz, d = b.options.labels, a = c ? a.width : a.height, b = c ? d.x - a * { left: 0, center: 0.5, right: 1 }[b.labelAlign] : 0; return [b, c ? a + b : a] }, handleOverflow: function (a, b) { var c = !0, d = this.axis, e = this.isFirst, f = this.isLast, g = d.horiz ? b.x : b.y, h = d.reversed, k = d.tickPositions, l = this.getLabelSides(), m = l[0], l = l[1], n, p, q, r = this.label.line || 0; n = d.labelEdge; p = d.justifyLabels && (e || f); n[r] === w || g + m > n[r] ? n[r] = g + l : p || (c = !1); if (p) { n = (p = d.justifyToPlot) ? d.pos : 0; p = p ? n + d.len : d.chart.chartWidth; do a += e ? 1 : -1, q = d.ticks[k[a]]; while (k[a] && (!q || !q.label || q.label.line !== r)); d = q && q.label.xy && q.label.xy.x + q.getLabelSides()[e ? 0 : 1]; e && !h || f && h ? g + m < n && (g = n - m, q && g + l > d && (c = !1)) : g + l > p && (g = p - l, q && g + m < d && (c = !1)); b.x = g } return c }, getPosition: function (a, b, c, d) { var e = this.axis, f = e.chart, g = d && f.oldChartHeight || f.chartHeight; return { x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0), y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB } }, getLabelPosition: function (a, b, c, d, e, f, g, h) { var k = this.axis, l = k.transA, m = k.reversed, n = k.staggerLines; a = a + e.x - (f && d ? f * l * (m ? -1 : 1) : 0); b = b + this.yOffset - (f && !d ? f * l * (m ? 1 : -1) : 0); n && (c.line = g / (h || 1) % n, b += c.line * (k.labelOffset / n)); return { x: a, y: b } }, getMarkPath: function (a, b, c, d, e, f) { return f.crispLine(["M", a, b, "L", a + (e ? 0 : -c), b + (e ? c : 0)], d) }, render: function (a, b, c) { var d = this.axis, e = d.options, f = d.chart.renderer, g = d.horiz, h = this.type, k = this.label, l = this.pos, m = e.labels, n = this.gridLine, p = h ? h + "Grid" : "grid", q = h ? h + "Tick" : "tick", r = e[p + "LineWidth"], t = e[p + "LineColor"], H = e[p + "LineDashStyle"], L = e[q + "Length"], p = e[q + "Width"] || 0, G = e[q + "Color"], x = e[q + "Position"], q = this.mark, v = m.step, u = !0, y = d.tickmarkOffset, z = this.getPosition(g, l, y, b), A = z.x, z = z.y, B = g && A === d.pos + d.len || !g && z === d.pos ? -1 : 1; c = s(c, 1); this.isActive = !0; if (r && (l = d.getPlotLinePath(l + y, r * B, b, !0), n === w && (n = { stroke: t, "stroke-width": r }, H && (n.dashstyle = H), h || (n.zIndex = 1), b && (n.opacity = 0), this.gridLine = n = r ? f.path(l).attr(n).add(d.gridGroup) : null), !b && n && l)) n[this.isNew ? "attr" : "animate"]({ d: l, opacity: c }); p && L && ("inside" === x && (L = -L), d.opposite && (L = -L), h = this.getMarkPath(A, z, L, p * B, g, f), q ? q.animate({ d: h, opacity: c }) : this.mark = f.path(h).attr({ stroke: G, "stroke-width": p, opacity: c }).add(d.axisGroup)); k && !isNaN(A) && (k.xy = z = this.getLabelPosition(A, z, k, g, m, y, a, v), this.isFirst && !this.isLast && !s(e.showFirstLabel, 1) || this.isLast && !this.isFirst && !s(e.showLastLabel, 1) ? u = !1 : d.isRadial || m.step || m.rotation || b || 0 === c || (u = this.handleOverflow(a, z)), v && a % v && (u = !1), u && !isNaN(z.y) ? (z.opacity = c, k[this.isNew ? "attr" : "animate"](z), this.isNew = !1) : k.attr("y", -9999)) }, destroy: function () { Pa(this, this.axis) } }; J.PlotLineOrBand = function (a, b) { this.axis = a; b && (this.options = b, this.id = b.id) }; J.PlotLineOrBand.prototype = { render: function () { var a = this, b = a.axis, c = b.horiz, d = (b.pointRange || 0) / 2, e = a.options, f = e.label, g = a.label, h = e.width, k = e.to, l = e.from, m = v(l) && v(k), n = e.value, p = e.dashStyle, q = a.svgElem, r = [], s, t = e.color, L = e.zIndex, G = e.events, u = {}, w = b.chart.renderer; b.isLog && (l = za(l), k = za(k), n = za(n)); if (h) r = b.getPlotLinePath(n, h), u = { stroke: t, "stroke-width": h }, p && (u.dashstyle = p); else if (m) l = x(l, b.min - d), k = F(k, b.max + d), r = b.getPlotBandPath(l, k, e), t && (u.fill = t), e.borderWidth && (u.stroke = e.borderColor, u["stroke-width"] = e.borderWidth); else return; v(L) && (u.zIndex = L); if (q) r ? q.animate({ d: r }, null, q.onGetPath) : (q.hide(), q.onGetPath = function () { q.show() }, g && (a.label = g = g.destroy())); else if (r && r.length && (a.svgElem = q = w.path(r).attr(u).add(), G)) for (s in d = function (b) { q.on(b, function (c) { G[b].apply(a, [c]) }) }, G) d(s); f && v(f.text) && r && r.length && 0 < b.width && 0 < b.height ? (f = A({ align: c && m && "center", x: c ? !m && 4 : 10, verticalAlign: !c && m && "middle", y: c ? m ? 16 : 10 : m ? 6 : -4, rotation: c && !m && 90 }, f), g || (u = { align: f.textAlign || f.align, rotation: f.rotation }, v(L) && (u.zIndex = L), a.label = g = w.text(f.text, 0, 0, f.useHTML).attr(u).css(f.style).add()), b = [r[1], r[4], m ? r[6] : r[1]], m = [r[2], r[5], m ? r[7] : r[2]], r = Oa(b), c = Oa(m), g.align(f, !1, { x: r, y: c, width: Ba(b) - r, height: Ba(m) - c }), g.show()) : g && g.hide(); return a }, destroy: function () { la(this.axis.plotLinesAndBands, this); delete this.axis; Pa(this) } }; na.prototype = { defaultOptions: { dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, gridLineColor: "#C0C0C0", labels: Cb, lineColor: "#C0D0E0", lineWidth: 1, minPadding: 0.01, maxPadding: 0.01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickColor: "#C0D0E0", tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", tickWidth: 1, title: { align: "middle", style: { color: "#707070" } }, type: "linear" }, defaultYAxisOptions: { endOnTick: !0, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8, y: 3 }, lineWidth: 0, maxPadding: 0.05, minPadding: 0.05, startOnTick: !0, tickWidth: 0, title: { rotation: 270, text: "Values" }, stackLabels: { enabled: !1, formatter: function () { return Ha(this.total, -1) }, style: Cb.style } }, defaultLeftAxisOptions: { labels: { x: -15, y: null }, title: { rotation: 270 } }, defaultRightAxisOptions: { labels: { x: 15, y: null }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { x: 0, y: null }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { x: 0, y: -15 }, title: { rotation: 0 } }, init: function (a, b) { var c = b.isX; this.horiz = a.inverted ? !c : c; this.coll = (this.isXAxis = c) ? "xAxis" : "yAxis"; this.opposite = b.opposite; this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3); this.setOptions(b); var d = this.options, e = d.type; this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter; this.userOptions = b; this.minPixelPadding = 0; this.chart = a; this.reversed = d.reversed; this.zoomEnabled = !1 !== d.zoomEnabled; this.categories = d.categories || "category" === e; this.names = []; this.isLog = "logarithmic" === e; this.isDatetimeAxis = "datetime" === e; this.isLinked = v(d.linkedTo); this.tickmarkOffset = this.categories && "between" === d.tickmarkPlacement ? 0.5 : 0; this.ticks = {}; this.labelEdge = []; this.minorTicks = {}; this.plotLinesAndBands = []; this.alternateBands = {}; this.len = 0; this.minRange = this.userMinRange = d.minRange || d.maxZoom; this.range = d.range; this.offset = d.offset || 0; this.stacks = {}; this.oldStacks = {}; this.min = this.max = null; this.crosshair = s(d.crosshair, ra(a.options.tooltip.crosshairs)[c ? 0 : 1], !1); var f, d = this.options.events; -1 === Da(this, a.axes) && (c && !this.isColorAxis ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this)); this.series = this.series || []; a.inverted && c && this.reversed === w && (this.reversed = !0); this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine; for (f in d) P(this, f, d[f]); this.isLog && (this.val2lin = za, this.lin2val = ka) }, setOptions: function (a) { this.options = A(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], A(K[this.coll], a)) }, defaultLabelFormatter: function () { var a = this.axis, b = this.value, c = a.categories, d = this.dateTimeLabelFormat, e = K.lang.numericSymbols, f = e && e.length, g, h = a.options.labels.format, a = a.isLog ? b : a.tickInterval; if (h) g = Ja(h, this); else if (c) g = b; else if (d) g = fb(d, b); else if (f && 1E3 <= a) for (; f-- && g === w;) c = Math.pow(1E3, f + 1), a >= c && null !== e[f] && (g = Ha(b / c, -1) + e[f]); g === w && (g = 1E4 <= S(b) ? Ha(b, 0) : Ha(b, -1, w, "")); return g }, getSeriesExtremes: function () { var a = this, b = a.chart; a.hasVisibleSeries = !1; a.dataMin = a.dataMax = null; a.buildStacks && a.buildStacks(); t(a.series, function (c) { if (c.visible || !b.options.chart.ignoreHiddenSeries) { var d; d = c.options.threshold; var e; a.hasVisibleSeries = !0; a.isLog && 0 >= d && (d = null); a.isXAxis ? (d = c.xData, d.length && (a.dataMin = F(s(a.dataMin, d[0]), Oa(d)), a.dataMax = x(s(a.dataMax, d[0]), Ba(d)))) : (c.getExtremes(), e = c.dataMax, c = c.dataMin, v(c) && v(e) && (a.dataMin = F(s(a.dataMin, c), c), a.dataMax = x(s(a.dataMax, e), e)), v(d) && (a.dataMin >= d ? (a.dataMin = d, a.ignoreMinPadding = !0) : a.dataMax < d && (a.dataMax = d, a.ignoreMaxPadding = !0))) } }) }, translate: function (a, b, c, d, e, f) { var g = 1, h = 0, k = d ? this.oldTransA : this.transA; d = d ? this.oldMin : this.min; var l = this.minPixelPadding; e = (this.options.ordinal || this.isLog && e) && this.lin2val; k || (k = this.transA); c && (g *= -1, h = this.len); this.reversed && (g *= -1, h -= g * (this.sector || this.len)); b ? (a = a * g + h - l, a = a / k + d, e && (a = this.lin2val(a))) : (e && (a = this.val2lin(a)), "between" === f && (f = 0.5), a = g * (a - d) * k + h + g * l + (ja(f) ? k * f * this.pointRange : 0)); return a }, toPixels: function (a, b) { return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos) }, toValue: function (a, b) { return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0) }, getPlotLinePath: function (a, b, c, d, e) { var f = this.chart, g = this.left, h = this.top, k, l, m = c && f.oldChartHeight || f.chartHeight, n = c && f.oldChartWidth || f.chartWidth, p; k = this.transB; e = s(e, this.translate(a, null, null, c)); a = c = y(e + k); k = l = y(m - e - k); if (isNaN(e)) p = !0; else if (this.horiz) { if (k = h, l = m - this.bottom, a < g || a > g + this.width) p = !0 } else if (a = g, c = n - this.right, k < h || k > h + this.height) p = !0; return p && !d ? null : f.renderer.crispLine(["M", a, k, "L", c, l], b || 1) }, getLinearTickPositions: function (a, b, c) { var d, e = fa(U(b / a) * a), f = fa(La(c / a) * a), g = []; if (b === c && ja(b)) return [b]; for (b = e; b <= f;) { g.push(b); b = fa(b + a); if (b === d) break; d = b } return g }, getMinorTickPositions: function () { var a = this.options, b = this.tickPositions, c = this.minorTickInterval, d = [], e; if (this.isLog) for (e = b.length, a = 1; a < e; a++) d = d.concat(this.getLogTickPositions(c, b[a - 1], b[a], !0)); else if (this.isDatetimeAxis && "auto" === a.minorTickInterval) d = d.concat(this.getTimeTicks(this.normalizeTimeTickInterval(c), this.min, this.max, a.startOfWeek)), d[0] < this.min && d.shift(); else for (b = this.min + (b[0] - this.min) % c; b <= this.max; b += c) d.push(b); return d }, adjustForMinRange: function () { var a = this.options, b = this.min, c = this.max, d, e = this.dataMax - this.dataMin >= this.minRange, f, g, h, k, l; this.isXAxis && this.minRange === w && !this.isLog && (v(a.min) || v(a.max) ? this.minRange = null : (t(this.series, function (a) { k = a.xData; for (g = l = a.xIncrement ? 1 : k.length - 1; 0 < g; g--) if (h = k[g] - k[g - 1], f === w || h < f) f = h }), this.minRange = F(5 * f, this.dataMax - this.dataMin))); if (c - b < this.minRange) { var m = this.minRange; d = (m - c + b) / 2; d = [b - d, s(a.min, b - d)]; e && (d[2] = this.dataMin); b = Ba(d); c = [b + m, s(a.max, b + m)]; e && (c[2] = this.dataMax); c = Oa(c); c - b < m && (d[0] = c - m, d[1] = s(a.min, c - m), b = Ba(d)) } this.min = b; this.max = c }, setAxisTranslation: function (a) { var b = this, c = b.max - b.min, d = b.axisPointRange || 0, e, f = 0, g = 0, h = b.linkedParent, k = !!b.categories, l = b.transA; if (b.isXAxis || k || d) h ? (f = h.minPointOffset, g = h.pointRangePadding) : t(b.series, function (a) { var h = k ? 1 : b.isXAxis ? a.pointRange : b.axisPointRange || 0, l = a.options.pointPlacement, q = a.closestPointRange; h > c && (h = 0); d = x(d, h); f = x(f, Ga(l) ? 0 : h / 2); g = x(g, "on" === l ? 0 : h); !a.noSharedTooltip && v(q) && (e = v(e) ? F(e, q) : q) }), h = b.ordinalSlope && e ? b.ordinalSlope / e : 1, b.minPointOffset = f *= h, b.pointRangePadding = g *= h, b.pointRange = F(d, c), b.closestPointRange = e; a && (b.oldTransA = l); b.translationSlope = b.transA = l = b.len / (c + g || 1); b.transB = b.horiz ? b.left : b.bottom; b.minPixelPadding = l * f }, setTickPositions: function (a) { var b = this, c = b.chart, d = b.options, e = d.startOnTick, f = d.endOnTick, g = b.isLog, h = b.isDatetimeAxis, k = b.isXAxis, l = b.isLinked, m = b.options.tickPositioner, n = d.maxPadding, p = d.minPadding, q = d.tickInterval, r = d.minTickInterval, Z = d.tickPixelInterval, H, L = b.categories; l ? (b.linkedParent = c[b.coll][d.linkedTo], c = b.linkedParent.getExtremes(), b.min = s(c.min, c.dataMin), b.max = s(c.max, c.dataMax), d.type !== b.linkedParent.options.type && pa(11, 1)) : (b.min = s(b.userMin, d.min, b.dataMin), b.max = s(b.userMax, d.max, b.dataMax)); g && (!a && 0 >= F(b.min, s(b.dataMin, b.min)) && pa(10, 1), b.min = fa(za(b.min)), b.max = fa(za(b.max))); b.range && v(b.max) && (b.userMin = b.min = x(b.min, b.max - b.range), b.userMax = b.max, b.range = null); b.beforePadding && b.beforePadding(); b.adjustForMinRange(); !(L || b.axisPointRange || b.usePercentage || l) && v(b.min) && v(b.max) && (c = b.max - b.min) && (v(d.min) || v(b.userMin) || !p || !(0 > b.dataMin) && b.ignoreMinPadding || (b.min -= c * p), v(d.max) || v(b.userMax) || !n || !(0 < b.dataMax) && b.ignoreMaxPadding || (b.max += c * n)); ja(d.floor) && (b.min = x(b.min, d.floor)); ja(d.ceiling) && (b.max = F(b.max, d.ceiling)); b.min === b.max || void 0 === b.min || void 0 === b.max ? b.tickInterval = 1 : l && !q && Z === b.linkedParent.options.tickPixelInterval ? b.tickInterval = b.linkedParent.tickInterval : (b.tickInterval = s(q, L ? 1 : (b.max - b.min) * Z / x(b.len, Z)), !v(q) && b.len < Z && !this.isRadial && !this.isLog && !L && e && f && (H = !0, b.tickInterval /= 4)); k && !a && t(b.series, function (a) { a.processData(b.min !== b.oldMin || b.max !== b.oldMax) }); b.setAxisTranslation(!0); b.beforeSetTickPositions && b.beforeSetTickPositions(); b.postProcessTickInterval && (b.tickInterval = b.postProcessTickInterval(b.tickInterval)); b.pointRange && (b.tickInterval = x(b.pointRange, b.tickInterval)); !q && b.tickInterval < r && (b.tickInterval = r); h || g || q || (b.tickInterval = sb(b.tickInterval, null, rb(b.tickInterval), d)); b.minorTickInterval = "auto" === d.minorTickInterval && b.tickInterval ? b.tickInterval / 5 : d.minorTickInterval; b.tickPositions = a = d.tickPositions ? [].concat(d.tickPositions) : m && m.apply(b, [b.min, b.max]); a || (!b.ordinalPositions && (b.max - b.min) / b.tickInterval > x(2 * b.len, 200) && pa(19, !0), a = h ? b.getTimeTicks(b.normalizeTimeTickInterval(b.tickInterval, d.units), b.min, b.max, d.startOfWeek, b.ordinalPositions, b.closestPointRange, !0) : g ? b.getLogTickPositions(b.tickInterval, b.min, b.max) : b.getLinearTickPositions(b.tickInterval, b.min, b.max), H && a.splice(1, a.length - 2), b.tickPositions = a); l || (d = a[0], g = a[a.length - 1], h = b.minPointOffset || 0, e || f || L || 2 !== a.length || a.splice(1, 0, (g + d) / 2), e ? b.min = d : b.min - h > d && a.shift(), f ? b.max = g : b.max + h < g && a.pop(), 1 === a.length && (e = 1E13 < S(b.max) ? 1 : 0.001, b.min -= e, b.max += e)) }, setMaxTicks: function () { var a = this.chart, b = a.maxTicks || {}, c = this.tickPositions, d = this._maxTicksKey = [this.coll, this.pos, this.len].join("-"); !this.isLinked && !this.isDatetimeAxis && c && c.length > (b[d] || 0) && !1 !== this.options.alignTicks && (b[d] = c.length); a.maxTicks = b }, adjustTickAmount: function () { var a = this._maxTicksKey, b = this.tickPositions, c = this.chart.maxTicks; if (c && c[a] && !this.isDatetimeAxis && !this.categories && !this.isLinked && !1 !== this.options.alignTicks && this.min !== w) { var d = this.tickAmount, e = b.length; this.tickAmount = a = c[a]; if (e < a) { for (; b.length < a;) b.push(fa(b[b.length - 1] + this.tickInterval)); this.transA *= (e - 1) / (a - 1); this.max = b[b.length - 1] } v(d) && a !== d && (this.isDirty = !0) } }, setScale: function () { var a = this.stacks, b, c, d, e; this.oldMin = this.min; this.oldMax = this.max; this.oldAxisLength = this.len; this.setAxisSize(); e = this.len !== this.oldAxisLength; t(this.series, function (a) { if (a.isDirtyData || a.isDirty || a.xAxis.isDirty) d = !0 }); if (e || d || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax) { if (!this.isXAxis) for (b in a) for (c in a[b]) a[b][c].total = null, a[b][c].cum = 0; this.forceRedraw = !1; this.getSeriesExtremes(); this.setTickPositions(); this.oldUserMin = this.userMin; this.oldUserMax = this.userMax; this.isDirty || (this.isDirty = e || this.min !== this.oldMin || this.max !== this.oldMax) } else if (!this.isXAxis) for (b in this.oldStacks && (a = this.stacks = this.oldStacks), a) for (c in a[b]) a[b][c].cum = a[b][c].total; this.setMaxTicks() }, setExtremes: function (a, b, c, d, e) { var f = this, g = f.chart; c = s(c, !0); e = u(e, { min: a, max: b }); N(f, "setExtremes", e, function () { f.userMin = a; f.userMax = b; f.eventArgs = e; f.isDirtyExtremes = !0; c && g.redraw(d) }) }, zoom: function (a, b) { var c = this.dataMin, d = this.dataMax, e = this.options; this.allowZoomOutside || (v(c) && a <= F(c, s(e.min, c)) && (a = w), v(d) && b >= x(d, s(e.max, d)) && (b = w)); this.displayBtn = a !== w || b !== w; this.setExtremes(a, b, !1, w, { trigger: "zoom" }); return !0 }, setAxisSize: function () { var a = this.chart, b = this.options, c = b.offsetLeft || 0, d = this.horiz, e = s(b.width, a.plotWidth - c + (b.offsetRight || 0)), f = s(b.height, a.plotHeight), g = s(b.top, a.plotTop), b = s(b.left, a.plotLeft + c), c = /%$/; c.test(f) && (f = parseInt(f, 10) / 100 * a.plotHeight); c.test(g) && (g = parseInt(g, 10) / 100 * a.plotHeight + a.plotTop); this.left = b; this.top = g; this.width = e; this.height = f; this.bottom = a.chartHeight - f - g; this.right = a.chartWidth - e - b; this.len = x(d ? e : f, 0); this.pos = d ? b : g }, getExtremes: function () { var a = this.isLog; return { min: a ? fa(ka(this.min)) : this.min, max: a ? fa(ka(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax } }, getThreshold: function (a) { var b = this.isLog, c = b ? ka(this.min) : this.min, b = b ? ka(this.max) : this.max; c > a || null === a ? a = c : b < a && (a = b); return this.translate(a, 0, 1, 0, 1) }, autoLabelAlign: function (a) { a = (s(a, 0) - 90 * this.side + 720) % 360; return 15 < a && 165 > a ? "right" : 195 < a && 345 > a ? "left" : "center" }, getOffset: function () { var a = this, b = a.chart, c = b.renderer, d = a.options, e = a.tickPositions, f = a.ticks, g = a.horiz, h = a.side, k = b.inverted ? [1, 0, 3, 2][h] : h, l, m, n = 0, p, q = 0, r = d.title, Z = d.labels, H = 0, L = b.axisOffset, b = b.clipOffset, G = [-1, 1, 1, -1][h], u, y = 1, z = s(Z.maxStaggerLines, 5), A, C, F, B, T; a.hasData = l = a.hasVisibleSeries || v(a.min) && v(a.max) && !!e; a.showAxis = m = l || s(d.showEmpty, !0); a.staggerLines = a.horiz && Z.staggerLines; a.axisGroup || (a.gridGroup = c.g("grid").attr({ zIndex: d.gridZIndex || 1 }).add(), a.axisGroup = c.g("axis").attr({ zIndex: d.zIndex || 2 }).add(), a.labelGroup = c.g("axis-labels").attr({ zIndex: Z.zIndex || 7 }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels").add()); if (l || a.isLinked) { a.labelAlign = s(Z.align || a.autoLabelAlign(Z.rotation)); t(e, function (b) { f[b] ? f[b].addLabel() : f[b] = new Ta(a, b) }); if (a.horiz && !a.staggerLines && z && !Z.rotation) { for (l = a.reversed ? [].concat(e).reverse() : e; y < z;) { A = []; C = !1; for (u = 0; u < l.length; u++) F = l[u], B = (B = f[F].label && f[F].label.getBBox()) ? B.width : 0, T = u % y, B && (F = a.translate(F), A[T] !== w && F < A[T] && (C = !0), A[T] = F + B); if (C) y++; else break } 1 < y && (a.staggerLines = y) } t(e, function (b) { if (0 === h || 2 === h || { 1: "left", 3: "right" }[h] === a.labelAlign) H = x(f[b].getLabelSize(), H) }); a.staggerLines && (H *= a.staggerLines, a.labelOffset = H) } else for (u in f) f[u].destroy(), delete f[u]; r && r.text && !1 !== r.enabled && (a.axisTitle || (a.axisTitle = c.text(r.text, 0, 0, r.useHTML).attr({ zIndex: 7, rotation: r.rotation || 0, align: r.textAlign || { low: "left", middle: "center", high: "right" }[r.align] }).addClass("highcharts-" + this.coll.toLowerCase() + "-title").css(r.style).add(a.axisGroup), a.axisTitle.isNew = !0), m && (n = a.axisTitle.getBBox()[g ? "height" : "width"], p = r.offset, q = v(p) ? 0 : s(r.margin, g ? 5 : 10)), a.axisTitle[m ? "show" : "hide"]()); a.offset = G * s(d.offset, L[h]); c = 2 === h ? a.tickBaseline : 0; g = H + q + (H && G * (g ? s(Z.y, a.tickBaseline + 8) : Z.x) - c); a.axisTitleMargin = s(p, g); L[h] = x(L[h], a.axisTitleMargin + n + G * a.offset, g); b[k] = x(b[k], 2 * U(d.lineWidth / 2)) }, getLinePath: function (a) { var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c ? this.width : 0) + d, d = b.chartHeight - this.bottom - (c ? this.height : 0) + d; c && (a *= -1); return b.renderer.crispLine(["M", e ? this.left : f, e ? d : this.top, "L", e ? b.chartWidth - this.right : f, e ? d : b.chartHeight - this.bottom], a) }, getTitlePosition: function () { var a = this.horiz, b = this.left, c = this.top, d = this.len, e = this.options.title, f = a ? b : c, g = this.opposite, h = this.offset, k = C(e.style.fontSize || 12), d = { low: f + (a ? 0 : d), middle: f + d / 2, high: f + (a ? d : 0) }[e.align], b = (a ? c + this.height : b) + (a ? 1 : -1) * (g ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? k : 0); return { x: a ? d : b + (g ? this.width : 0) + h + (e.x || 0), y: a ? b - (g ? this.height : 0) + h : d + (e.y || 0) } }, render: function () { var a = this, b = a.horiz, c = a.reversed, d = a.chart, e = d.renderer, f = a.options, g = a.isLog, h = a.isLinked, k = a.tickPositions, l, m = a.axisTitle, n = a.ticks, p = a.minorTicks, q = a.alternateBands, r = f.stackLabels, s = f.alternateGridColor, H = a.tickmarkOffset, L = f.lineWidth, G = d.hasRendered && v(a.oldMin) && !isNaN(a.oldMin), u = a.hasData, x = a.showAxis, y, z = f.labels.overflow, A = a.justifyLabels = b && !1 !== z, C; a.labelEdge.length = 0; a.justifyToPlot = "justify" === z; t([n, p, q], function (a) { for (var b in a) a[b].isActive = !1 }); if (u || h) a.minorTickInterval && !a.categories && t(a.getMinorTickPositions(), function (b) { p[b] || (p[b] = new Ta(a, b, "minor")); G && p[b].isNew && p[b].render(null, !0); p[b].render(null, !1, 1) }), k.length && (l = k.slice(), (b && c || !b && !c) && l.reverse(), A && (l = l.slice(1).concat([l[0]])), t(l, function (b, c) { A && (c = c === l.length - 1 ? 0 : c + 1); if (!h || b >= a.min && b <= a.max) n[b] || (n[b] = new Ta(a, b)), G && n[b].isNew && n[b].render(c, !0, 0.1), n[b].render(c) }), H && 0 === a.min && (n[-1] || (n[-1] = new Ta(a, -1, null, !0)), n[-1].render(-1))), s && t(k, function (b, c) { 0 === c % 2 && b < a.max && (q[b] || (q[b] = new J.PlotLineOrBand(a)), y = b + H, C = k[c + 1] !== w ? k[c + 1] + H : a.max, q[b].options = { from: g ? ka(y) : y, to: g ? ka(C) : C, color: s }, q[b].render(), q[b].isActive = !0) }), a._addedPlotLB || (t((f.plotLines || []).concat(f.plotBands || []), function (b) { a.addPlotBandOrLine(b) }), a._addedPlotLB = !0); t([n, p, q], function (a) { var b, c, e = [], f = va ? va.duration || 500 : 0, g = function () { for (c = e.length; c--;) a[e[c]] && !a[e[c]].isActive && (a[e[c]].destroy(), delete a[e[c]]) }; for (b in a) a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, e.push(b)); a !== q && d.hasRendered && f ? f && setTimeout(g, f) : g() }); L && (b = a.getLinePath(L), a.axisLine ? a.axisLine.animate({ d: b }) : a.axisLine = e.path(b).attr({ stroke: f.lineColor, "stroke-width": L, zIndex: 7 }).add(a.axisGroup), a.axisLine[x ? "show" : "hide"]()); m && x && (m[m.isNew ? "attr" : "animate"](a.getTitlePosition()), m.isNew = !1); r && r.enabled && a.renderStackTotals(); a.isDirty = !1 }, redraw: function () { this.render(); t(this.plotLinesAndBands, function (a) { a.render() }); t(this.series, function (a) { a.isDirty = !0 }) }, destroy: function (a) { var b = this, c = b.stacks, d, e = b.plotLinesAndBands; a || Y(b); for (d in c) Pa(c[d]), c[d] = null; t([b.ticks, b.minorTicks, b.alternateBands], function (a) { Pa(a) }); for (a = e.length; a--;) e[a].destroy(); t("stackTotalGroup axisLine axisTitle axisGroup cross gridGroup labelGroup".split(" "), function (a) { b[a] && (b[a] = b[a].destroy()) }); this.cross && this.cross.destroy() }, drawCrosshair: function (a, b) { if (this.crosshair) if (!1 === (v(b) || !s(this.crosshair.snap, !0))) this.hideCrosshair(); else { var c, d = this.crosshair, e = d.animation; s(d.snap, !0) ? v(b) && (c = this.chart.inverted != this.horiz ? b.plotX : this.len - b.plotY) : c = this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos; c = this.isRadial ? this.getPlotLinePath(this.isXAxis ? b.x : s(b.stackY, b.y)) : this.getPlotLinePath(null, null, null, null, c); if (null === c) this.hideCrosshair(); else if (this.cross) this.cross.attr({ visibility: "visible" })[e ? "animate" : "attr"]({ d: c }, e); else e = { "stroke-width": d.width || 1, stroke: d.color || "#C0C0C0", zIndex: d.zIndex || 2 }, d.dashStyle && (e.dashstyle = d.dashStyle), this.cross = this.chart.renderer.path(c).attr(e).add() } }, hideCrosshair: function () { this.cross && this.cross.hide() } }; u(na.prototype, { getPlotBandPath: function (a, b) { var c = this.getPlotLinePath(b), d = this.getPlotLinePath(a); d && c ? d.push(c[4], c[5], c[1], c[2]) : d = null; return d }, addPlotBand: function (a) { return this.addPlotBandOrLine(a, "plotBands") }, addPlotLine: function (a) { return this.addPlotBandOrLine(a, "plotLines") }, addPlotBandOrLine: function (a, b) { var c = (new J.PlotLineOrBand(this, a)).render(), d = this.userOptions; c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c)); return c }, removePlotBandOrLine: function (a) { for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--;) b[e].id === a && b[e].destroy(); t([c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || []], function (b) { for (e = b.length; e--;) b[e].id === a && la(b, b[e]) }) } }); na.prototype.getTimeTicks = function (a, b, c, d) { var e = [], f = {}, g = K.global.useUTC, h, k = new Date(b - Sa), l = a.unitRange, m = a.count; if (v(b)) { l >= E.second && (k.setMilliseconds(0), k.setSeconds(l >= E.minute ? 0 : m * U(k.getSeconds() / m))); if (l >= E.minute) k[Nb](l >= E.hour ? 0 : m * U(k[ub]() / m)); if (l >= E.hour) k[Ob](l >= E.day ? 0 : m * U(k[vb]() / m)); if (l >= E.day) k[xb](l >= E.month ? 1 : m * U(k[Xa]() / m)); l >= E.month && (k[Pb](l >= E.year ? 0 : m * U(k[ib]() / m)), h = k[jb]()); if (l >= E.year) k[Qb](h - h % m); if (l === E.week) k[xb](k[Xa]() - k[wb]() + s(d, 1)); b = 1; Sa && (k = new Date(k.getTime() + Sa)); h = k[jb](); d = k.getTime(); for (var n = k[ib](), p = k[Xa](), q = g ? Sa : (864E5 + 6E4 * k.getTimezoneOffset()) % 864E5; d < c;) e.push(d), d = l === E.year ? hb(h + b * m, 0) : l === E.month ? hb(h, n + b * m) : g || l !== E.day && l !== E.week ? d + l * m : hb(h, n, p + b * m * (l === E.day ? 1 : 7)), b++; e.push(d); t(Bb(e, function (a) { return l <= E.hour && a % E.day === q }), function (a) { f[a] = "day" }) } e.info = u(a, { higherRanks: f, totalRange: l * m }); return e }; na.prototype.normalizeTimeTickInterval = function (a, b) { var c = b || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], d = c[c.length - 1], e = E[d[0]], f = d[1], g; for (g = 0; g < c.length && !(d = c[g], e = E[d[0]], f = d[1], c[g + 1] && a <= (e * f[f.length - 1] + E[c[g + 1][0]]) / 2) ; g++); e === E.year && a < 5 * e && (f = [1, 2, 5]); c = sb(a / e, f, "year" === d[0] ? x(rb(a / e), 1) : 1); return { unitRange: e, count: c, unitName: d[0] } }; na.prototype.getLogTickPositions = function (a, b, c, d) { var e = this.options, f = this.len, g = []; d || (this._minorAutoInterval = null); if (0.5 <= a) a = y(a), g = this.getLinearTickPositions(a, b, c); else if (0.08 <= a) for (var f = U(b), h, k, l, m, n, e = 0.3 < a ? [1, 2, 4] : 0.15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f < c + 1 && !n; f++) for (k = e.length, h = 0; h < k && !n; h++) l = za(ka(f) * e[h]), l > b && (!d || m <= c) && m !== w && g.push(m), m > c && (n = !0), m = l; else b = ka(b), c = ka(c), a = e[d ? "minorTickInterval" : "tickInterval"], a = s("auto" === a ? null : a, this._minorAutoInterval, (c - b) * (e.tickPixelInterval / (d ? 5 : 1)) / ((d ? f / this.tickPositions.length : f) || 1)), a = sb(a, null, rb(a)), g = Va(this.getLinearTickPositions(a, b, c), za), d || (this._minorAutoInterval = a / 5); d || (this.tickInterval = a); return g }; var Yb = J.Tooltip = function () { this.init.apply(this, arguments) }; Yb.prototype = { init: function (a, b) { var c = b.borderWidth, d = b.style, e = C(d.padding); this.chart = a; this.options = b; this.crosshairs = []; this.now = { x: 0, y: 0 }; this.isHidden = !0; this.label = a.renderer.label("", 0, 0, b.shape || "callout", null, null, b.useHTML, null, "tooltip").attr({ padding: e, fill: b.backgroundColor, "stroke-width": c, r: b.borderRadius, zIndex: 8 }).css(d).css({ padding: 0 }).add().attr({ y: -9999 }); ha || this.label.shadow(b.shadow); this.shared = b.shared }, destroy: function () { this.label && (this.label = this.label.destroy()); clearTimeout(this.hideTimer); clearTimeout(this.tooltipTimeout) }, move: function (a, b, c, d) { var e = this, f = e.now, g = !1 !== e.options.animation && !e.isHidden && (1 < S(a - f.x) || 1 < S(b - f.y)), h = e.followPointer || 1 < e.len; u(f, { x: g ? (2 * f.x + a) / 3 : a, y: g ? (f.y + b) / 2 : b, anchorX: h ? w : g ? (2 * f.anchorX + c) / 3 : c, anchorY: h ? w : g ? (f.anchorY + d) / 2 : d }); e.label.attr(f); g && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () { e && e.move(a, b, c, d) }, 32)) }, hide: function () { var a = this, b; clearTimeout(this.hideTimer); this.isHidden || (b = this.chart.hoverPoints, this.hideTimer = setTimeout(function () { a.label.fadeOut(); a.isHidden = !0 }, s(this.options.hideDelay, 500)), b && t(b, function (a) { a.setState() }), this.chart.hoverPoints = null) }, getAnchor: function (a, b) { var c, d = this.chart, e = d.inverted, f = d.plotTop, g = 0, h = 0, k; a = ra(a); c = a[0].tooltipPos; this.followPointer && b && (b.chartX === w && (b = d.pointer.normalize(b)), c = [b.chartX - d.plotLeft, b.chartY - f]); c || (t(a, function (a) { k = a.series.yAxis; g += a.plotX; h += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!e && k ? k.top - f : 0) }), g /= a.length, h /= a.length, c = [e ? d.plotWidth - h : g, this.shared && !e && 1 < a.length && b ? b.chartY - f : e ? d.plotHeight - g : h]); return Va(c, y) }, getPosition: function (a, b, c) { var d = this.chart, e = this.distance, f = {}, g, h = ["y", d.chartHeight, b, c.plotY + d.plotTop], k = ["x", d.chartWidth, a, c.plotX + d.plotLeft], l = c.ttBelow || d.inverted && !c.negative || !d.inverted && c.negative, m = function (a, b, c, d) { var g = c < d - e; b = d + e + c < b; c = d - e - c; d += e; if (l && b) f[a] = d; else if (!l && g) f[a] = c; else if (g) f[a] = c; else if (b) f[a] = d; else return !1 }, n = function (a, b, c, d) { if (d < e || d > b - e) return !1; f[a] = d < c / 2 ? 1 : d > b - c / 2 ? b - c - 2 : d - c / 2 }, p = function (a) { var b = h; h = k; k = b; g = a }, q = function () { !1 !== m.apply(0, h) ? !1 !== n.apply(0, k) || g || (p(!0), q()) : g ? f.x = f.y = 0 : (p(!0), q()) }; (d.inverted || 1 < this.len) && p(); q(); return f }, defaultFormatter: function (a) { var b = this.points || ra(this), c = b[0].series, d; d = [a.tooltipHeaderFormatter(b[0])]; t(b, function (a) { c = a.series; d.push(c.tooltipFormatter && c.tooltipFormatter(a) || a.point.tooltipFormatter(c.tooltipOptions.pointFormat)) }); d.push(a.options.footerFormat || ""); return d.join("") }, refresh: function (a, b) { var c = this.chart, d = this.label, e = this.options, f, g, h = {}, k, l = []; k = e.formatter || this.defaultFormatter; var h = c.hoverPoints, m, n = this.shared; clearTimeout(this.hideTimer); this.followPointer = ra(a)[0].series.tooltipOptions.followPointer; g = this.getAnchor(a, b); f = g[0]; g = g[1]; !n || a.series && a.series.noSharedTooltip ? h = a.getLabelConfig() : (c.hoverPoints = a, h && t(h, function (a) { a.setState() }), t(a, function (a) { a.setState("hover"); l.push(a.getLabelConfig()) }), h = { x: a[0].category, y: a[0].y }, h.points = l, this.len = l.length, a = a[0]); k = k.call(h, this); h = a.series; this.distance = s(h.tooltipOptions.distance, 16); !1 === k ? this.hide() : (this.isHidden && (cb(d), d.attr("opacity", 1).show()), d.attr({ text: k }), m = e.borderColor || a.color || h.color || "#606060", d.attr({ stroke: m }), this.updatePosition({ plotX: f, plotY: g, negative: a.negative, ttBelow: a.ttBelow }), this.isHidden = !1); N(c, "tooltipRefresh", { text: k, x: f + c.plotLeft, y: g + c.plotTop, borderColor: m }) }, updatePosition: function (a) { var b = this.chart, c = this.label, c = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a); this.move(y(c.x), y(c.y), a.plotX + b.plotLeft, a.plotY + b.plotTop) }, tooltipHeaderFormatter: function (a) { var b = a.series, c = b.tooltipOptions, d = c.dateTimeLabelFormats, e = c.xDateFormat, f = b.xAxis, g = f && "datetime" === f.options.type && ja(a.key), c = c.headerFormat, f = f && f.closestPointRange, h; if (g && !e) { if (f) for (h in E) { if (E[h] >= f || E[h] <= E.day && 0 < a.key % E[h]) { e = d[h]; break } } else e = d.day; e = e || d.year } g && e && (c = c.replace("{point.key}", "{point.key:" + e + "}")); return Ja(c, { point: a, series: b }) } }; var qa; $a = z.documentElement.ontouchstart !== w; var Wa = J.Pointer = function (a, b) { this.init(a, b) }; Wa.prototype = { init: function (a, b) { var c = b.chart, d = c.events, e = ha ? "" : c.zoomType, c = a.inverted, f; this.options = b; this.chart = a; this.zoomX = f = /x/.test(e); this.zoomY = e = /y/.test(e); this.zoomHor = f && !c || e && c; this.zoomVert = e && !c || f && c; this.hasZoom = f || e; this.runChartClick = d && !!d.click; this.pinchDown = []; this.lastValidTouch = {}; J.Tooltip && b.tooltip.enabled && (a.tooltip = new Yb(a, b.tooltip), this.followTouchMove = b.tooltip.followTouchMove); this.setDOMEvents() }, normalize: function (a, b) { var c, d; a = a || window.event; a = gc(a); a.target || (a.target = a.srcElement); d = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a; b || (this.chartPosition = b = fc(this.chart.container)); d.pageX === w ? (c = x(a.x, a.clientX - b.left), d = a.y) : (c = d.pageX - b.left, d = d.pageY - b.top); return u(a, { chartX: y(c), chartY: y(d) }) }, getCoordinates: function (a) { var b = { xAxis: [], yAxis: [] }; t(this.chart.axes, function (c) { b[c.isXAxis ? "xAxis" : "yAxis"].push({ axis: c, value: c.toValue(a[c.horiz ? "chartX" : "chartY"]) }) }); return b }, getIndex: function (a) { var b = this.chart; return b.inverted ? b.plotHeight + b.plotTop - a.chartY : a.chartX - b.plotLeft }, runPointActions: function (a) { var b = this.chart, c = b.series, d = b.tooltip, e, f, g = b.hoverPoint, h = b.hoverSeries, k, l, m = b.chartWidth, n = this.getIndex(a); if (d && this.options.tooltip.shared && (!h || !h.noSharedTooltip)) { f = []; k = c.length; for (l = 0; l < k; l++) c[l].visible && !1 !== c[l].options.enableMouseTracking && !c[l].noSharedTooltip && !0 !== c[l].singularTooltips && c[l].tooltipPoints.length && (e = c[l].tooltipPoints[n]) && e.series && (e._dist = S(n - e.clientX), m = F(m, e._dist), f.push(e)); for (k = f.length; k--;) f[k]._dist > m && f.splice(k, 1); f.length && f[0].clientX !== this.hoverX && (d.refresh(f, a), this.hoverX = f[0].clientX) } c = h && h.tooltipOptions.followPointer; if (h && h.tracker && !c) { if ((e = h.tooltipPoints[n]) && e !== g) e.onMouseOver(a) } else d && c && !d.isHidden && (h = d.getAnchor([{}], a), d.updatePosition({ plotX: h[0], plotY: h[1] })); d && !this._onDocumentMouseMove && (this._onDocumentMouseMove = function (a) { if (X[qa]) X[qa].pointer.onDocumentMouseMove(a) }, P(z, "mousemove", this._onDocumentMouseMove)); t(b.axes, function (b) { b.drawCrosshair(a, s(e, g)) }) }, reset: function (a) { var b = this.chart, c = b.hoverSeries, d = b.hoverPoint, e = b.tooltip, f = e && e.shared ? b.hoverPoints : d; (a = a && e && f) && ra(f)[0].plotX === w && (a = !1); if (a) e.refresh(f), d && d.setState(d.state, !0); else { if (d) d.onMouseOut(); if (c) c.onMouseOut(); e && e.hide(); this._onDocumentMouseMove && (Y(z, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null); t(b.axes, function (a) { a.hideCrosshair() }); this.hoverX = null } }, scaleGroups: function (a, b) { var c = this.chart, d; t(c.series, function (e) { d = a || e.getPlotBox(); e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(d), e.markerGroup && (e.markerGroup.attr(d), e.markerGroup.clip(b ? c.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(d)) }); c.clipRect.attr(b || c.clipBox) }, dragStart: function (a) { var b = this.chart; b.mouseIsDown = a.type; b.cancelClick = !1; b.mouseDownX = this.mouseDownX = a.chartX; b.mouseDownY = this.mouseDownY = a.chartY }, drag: function (a) { var b = this.chart, c = b.options.chart, d = a.chartX, e = a.chartY, f = this.zoomHor, g = this.zoomVert, h = b.plotLeft, k = b.plotTop, l = b.plotWidth, m = b.plotHeight, n, p = this.mouseDownX, q = this.mouseDownY, r = c.panKey && a[c.panKey + "Key"]; d < h ? d = h : d > h + l && (d = h + l); e < k ? e = k : e > k + m && (e = k + m); this.hasDragged = Math.sqrt(Math.pow(p - d, 2) + Math.pow(q - e, 2)); 10 < this.hasDragged && (n = b.isInsidePlot(p - h, q - k), b.hasCartesianSeries && (this.zoomX || this.zoomY) && n && !r && !this.selectionMarker && (this.selectionMarker = b.renderer.rect(h, k, f ? 1 : l, g ? 1 : m, 0).attr({ fill: c.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7 }).add()), this.selectionMarker && f && (d -= p, this.selectionMarker.attr({ width: S(d), x: (0 < d ? 0 : d) + p })), this.selectionMarker && g && (d = e - q, this.selectionMarker.attr({ height: S(d), y: (0 < d ? 0 : d) + q })), n && !this.selectionMarker && c.panning && b.pan(a, c.panning)) }, drop: function (a) { var b = this.chart, c = this.hasPinched; if (this.selectionMarker) { var d = { xAxis: [], yAxis: [], originalEvent: a.originalEvent || a }, e = this.selectionMarker, f = e.attr ? e.attr("x") : e.x, g = e.attr ? e.attr("y") : e.y, h = e.attr ? e.attr("width") : e.width, k = e.attr ? e.attr("height") : e.height, l; if (this.hasDragged || c) t(b.axes, function (b) { if (b.zoomEnabled) { var c = b.horiz, e = "touchend" === a.type ? b.minPixelPadding : 0, q = b.toValue((c ? f : g) + e), c = b.toValue((c ? f + h : g + k) - e); isNaN(q) || isNaN(c) || (d[b.coll].push({ axis: b, min: F(q, c), max: x(q, c) }), l = !0) } }), l && N(b, "selection", d, function (a) { b.zoom(u(a, c ? { animation: !1 } : null)) }); this.selectionMarker = this.selectionMarker.destroy(); c && this.scaleGroups() } b && (D(b.container, { cursor: b._cursor }), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []) }, onContainerMouseDown: function (a) { a = this.normalize(a); a.preventDefault && a.preventDefault(); this.dragStart(a) }, onDocumentMouseUp: function (a) { X[qa] && X[qa].pointer.drop(a) }, onDocumentMouseMove: function (a) { var b = this.chart, c = this.chartPosition, d = b.hoverSeries; a = this.normalize(a, c); c && d && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset() }, onContainerMouseLeave: function () { var a = X[qa]; a && (a.pointer.reset(), a.pointer.chartPosition = null) }, onContainerMouseMove: function (a) { var b = this.chart; qa = b.index; a = this.normalize(a); a.returnValue = !1; "mousedown" === b.mouseIsDown && this.drag(a); !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a) }, inClass: function (a, b) { for (var c; a;) { if (c = R(a, "class")) { if (-1 !== c.indexOf(b)) return !0; if (-1 !== c.indexOf("highcharts-container")) return !1 } a = a.parentNode } }, onTrackerMouseOut: function (a) { var b = this.chart.hoverSeries, c = (a = a.relatedTarget || a.toElement) && a.point && a.point.series; if (b && !b.options.stickyTracking && !this.inClass(a, "highcharts-tooltip") && c !== b) b.onMouseOut() }, onContainerClick: function (a) { var b = this.chart, c = b.hoverPoint, d = b.plotLeft, e = b.plotTop; a = this.normalize(a); a.cancelBubble = !0; b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (N(c.series, "click", u(a, { point: c })), b.hoverPoint && c.firePointEvent("click", a)) : (u(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - d, a.chartY - e) && N(b, "click", a))) }, setDOMEvents: function () { var a = this, b = a.chart.container; b.onmousedown = function (b) { a.onContainerMouseDown(b) }; b.onmousemove = function (b) { a.onContainerMouseMove(b) }; b.onclick = function (b) { a.onContainerClick(b) }; P(b, "mouseleave", a.onContainerMouseLeave); 1 === ab && P(z, "mouseup", a.onDocumentMouseUp); $a && (b.ontouchstart = function (b) { a.onContainerTouchStart(b) }, b.ontouchmove = function (b) { a.onContainerTouchMove(b) }, 1 === ab && P(z, "touchend", a.onDocumentTouchEnd)) }, destroy: function () { var a; Y(this.chart.container, "mouseleave", this.onContainerMouseLeave); ab || (Y(z, "mouseup", this.onDocumentMouseUp), Y(z, "touchend", this.onDocumentTouchEnd)); clearInterval(this.tooltipTimeout); for (a in this) this[a] = null } }; u(J.Pointer.prototype, { pinchTranslate: function (a, b, c, d, e, f) { (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, a, b, c, d, e, f); (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, a, b, c, d, e, f) }, pinchTranslateDirection: function (a, b, c, d, e, f, g, h) { var k = this.chart, l = a ? "x" : "y", m = a ? "X" : "Y", n = "chart" + m, p = a ? "width" : "height", q = k["plot" + (a ? "Left" : "Top")], r, s, t = h || 1, u = k.inverted, G = k.bounds[a ? "h" : "v"], x = 1 === b.length, v = b[0][n], y = c[0][n], w = !x && b[1][n], z = !x && c[1][n], A; c = function () { !x && 20 < S(v - w) && (t = h || S(y - z) / S(v - w)); s = (q - y) / t + v; r = k["plot" + (a ? "Width" : "Height")] / t }; c(); b = s; b < G.min ? (b = G.min, A = !0) : b + r > G.max && (b = G.max - r, A = !0); A ? (y -= 0.8 * (y - g[l][0]), x || (z -= 0.8 * (z - g[l][1])), c()) : g[l] = [y, z]; u || (f[l] = s - q, f[p] = r); f = u ? 1 / t : t; e[p] = r; e[l] = b; d[u ? a ? "scaleY" : "scaleX" : "scale" + m] = t; d["translate" + m] = f * q + (y - f * v) }, pinch: function (a) { var b = this, c = b.chart, d = b.pinchDown, e = b.followTouchMove, f = a.touches, g = f.length, h = b.lastValidTouch, k = b.hasZoom, l = b.selectionMarker, m = {}, n = 1 === g && (b.inClass(a.target, "highcharts-tracker") && c.runTrackerClick || c.runChartClick), p = {}; !k && !e || n || a.preventDefault(); Va(f, function (a) { return b.normalize(a) }); "touchstart" === a.type ? (t(f, function (a, b) { d[b] = { chartX: a.chartX, chartY: a.chartY } }), h.x = [d[0].chartX, d[1] && d[1].chartX], h.y = [d[0].chartY, d[1] && d[1].chartY], t(c.axes, function (a) { if (a.zoomEnabled) { var b = c.bounds[a.horiz ? "h" : "v"], d = a.minPixelPadding, e = a.toPixels(s(a.options.min, a.dataMin)), f = a.toPixels(s(a.options.max, a.dataMax)), g = F(e, f), e = x(e, f); b.min = F(a.pos, g - d); b.max = x(a.pos + a.len, e + d) } })) : d.length && (l || (b.selectionMarker = l = u({ destroy: sa }, c.plotBox)), b.pinchTranslate(d, f, m, l, p, h), b.hasPinched = k, b.scaleGroups(m, p), !k && e && 1 === g && this.runPointActions(b.normalize(a))) }, onContainerTouchStart: function (a) { var b = this.chart; qa = b.index; 1 === a.touches.length ? (a = this.normalize(a), b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) ? (this.runPointActions(a), this.pinch(a)) : this.reset()) : 2 === a.touches.length && this.pinch(a) }, onContainerTouchMove: function (a) { 1 !== a.touches.length && 2 !== a.touches.length || this.pinch(a) }, onDocumentTouchEnd: function (a) { X[qa] && X[qa].pointer.drop(a) } }); if (I.PointerEvent || I.MSPointerEvent) { var ua = {}, Hb = !!I.PointerEvent, lc = function () { var a, b = []; b.item = function (a) { return this[a] }; for (a in ua) ua.hasOwnProperty(a) && b.push({ pageX: ua[a].pageX, pageY: ua[a].pageY, target: ua[a].target }); return b }, Ib = function (a, b, c, d) { a = a.originalEvent || a; "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !X[qa] || (d(a), d = X[qa].pointer, d[b]({ type: c, target: a.currentTarget, preventDefault: sa, touches: lc() })) }; u(Wa.prototype, { onContainerPointerDown: function (a) { Ib(a, "onContainerTouchStart", "touchstart", function (a) { ua[a.pointerId] = { pageX: a.pageX, pageY: a.pageY, target: a.currentTarget } }) }, onContainerPointerMove: function (a) { Ib(a, "onContainerTouchMove", "touchmove", function (a) { ua[a.pointerId] = { pageX: a.pageX, pageY: a.pageY }; ua[a.pointerId].target || (ua[a.pointerId].target = a.currentTarget) }) }, onDocumentPointerUp: function (a) { Ib(a, "onContainerTouchEnd", "touchend", function (a) { delete ua[a.pointerId] }) }, batchMSEvents: function (a) { a(this.chart.container, Hb ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown); a(this.chart.container, Hb ? "pointermove" : "MSPointerMove", this.onContainerPointerMove); a(z, Hb ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp) } }); Na(Wa.prototype, "init", function (a, b, c) { a.call(this, b, c); (this.hasZoom || this.followTouchMove) && D(b.container, { "-ms-touch-action": V, "touch-action": V }) }); Na(Wa.prototype, "setDOMEvents", function (a) { a.apply(this); (this.hasZoom || this.followTouchMove) && this.batchMSEvents(P) }); Na(Wa.prototype, "destroy", function (a) { this.batchMSEvents(Y); a.call(this) }) } var pb = J.Legend = function (a, b) { this.init(a, b) }; pb.prototype = { init: function (a, b) { var c = this, d = b.itemStyle, e = s(b.padding, 8), f = b.itemMarginTop || 0; this.options = b; b.enabled && (c.itemStyle = d, c.itemHiddenStyle = A(d, b.itemHiddenStyle), c.itemMarginTop = f, c.padding = e, c.initialItemX = e, c.initialItemY = e - 5, c.maxItemWidth = 0, c.chart = a, c.itemHeight = 0, c.lastLineHeight = 0, c.symbolWidth = s(b.symbolWidth, 16), c.pages = [], c.render(), P(c.chart, "endResize", function () { c.positionCheckboxes() })) }, colorizeItem: function (a, b) { var c = this.options, d = a.legendItem, e = a.legendLine, f = a.legendSymbol, g = this.itemHiddenStyle.color, c = b ? c.itemStyle.color : g, h = b ? a.legendColor || a.color || "#CCC" : g, g = a.options && a.options.marker, k = { fill: h }, l; d && d.css({ fill: c, color: c }); e && e.attr({ stroke: h }); if (f) { if (g && f.isMarker) for (l in k.stroke = h, g = a.convertAttribs(g), g) d = g[l], d !== w && (k[l] = d); f.attr(k) } }, positionItem: function (a) { var b = this.options, c = b.symbolPadding, b = !b.rtl, d = a._legendItemPos, e = d[0], d = d[1], f = a.checkbox; a.legendGroup && a.legendGroup.translate(b ? e : this.legendWidth - e - 2 * c - 4, d); f && (f.x = e, f.y = d) }, destroyItem: function (a) { var b = a.checkbox; t(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (b) { a[b] && (a[b] = a[b].destroy()) }); b && Qa(a.checkbox) }, destroy: function () { var a = this.group, b = this.box; b && (this.box = b.destroy()); a && (this.group = a.destroy()) }, positionCheckboxes: function (a) { var b = this.group.alignAttr, c, d = this.clipHeight || this.legendHeight; b && (c = b.translateY, t(this.allItems, function (e) { var f = e.checkbox, g; f && (g = c + f.y + (a || 0) + 3, D(f, { left: b.translateX + e.checkboxOffset + f.x - 20 + "px", top: g + "px", display: g > c - 6 && g < c + d - 6 ? "" : V })) })) }, renderTitle: function () { var a = this.padding, b = this.options.title, c = 0; b.text && (this.title || (this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({ zIndex: 1 }).css(b.style).add(this.group)), a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, this.contentGroup.attr({ translateY: c })); this.titleHeight = c }, renderItem: function (a) { var b = this.chart, c = b.renderer, d = this.options, e = "horizontal" === d.layout, f = this.symbolWidth, g = d.symbolPadding, h = this.itemStyle, k = this.itemHiddenStyle, l = this.padding, m = e ? s(d.itemDistance, 20) : 0, n = !d.rtl, p = d.width, q = d.itemMarginBottom || 0, r = this.itemMarginTop, t = this.initialItemX, u = a.legendItem, v = a.series && a.series.drawLegendSymbol ? a.series : a, G = v.options, G = this.createCheckboxForItem && G && G.showCheckbox, w = d.useHTML; u || (a.legendGroup = c.g("legend-item").attr({ zIndex: 1 }).add(this.scrollGroup), a.legendItem = u = c.text(d.labelFormat ? Ja(d.labelFormat, a) : d.labelFormatter.call(a), n ? f + g : -g, this.baseline || 0, w).css(A(a.visible ? h : k)).attr({ align: n ? "left" : "right", zIndex: 2 }).add(a.legendGroup), this.baseline || (this.baseline = c.fontMetrics(h.fontSize, u).f + 3 + r, u.attr("y", this.baseline)), v.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, u, w, h, k), this.colorizeItem(a, a.visible), G && this.createCheckboxForItem(a)); c = u.getBBox(); f = a.checkboxOffset = d.itemWidth || a.legendItemWidth || f + g + c.width + m + (G ? 20 : 0); this.itemHeight = g = y(a.legendItemHeight || c.height); e && this.itemX - t + f > (p || b.chartWidth - 2 * l - t - d.x) && (this.itemX = t, this.itemY += r + this.lastLineHeight + q, this.lastLineHeight = 0); this.maxItemWidth = x(this.maxItemWidth, f); this.lastItemY = r + this.itemY + q; this.lastLineHeight = x(g, this.lastLineHeight); a._legendItemPos = [this.itemX, this.itemY]; e ? this.itemX += f : (this.itemY += r + g + q, this.lastLineHeight = g); this.offsetWidth = p || x((e ? this.itemX - t - m : f) + l, this.offsetWidth) }, getAllItems: function () { var a = []; t(this.chart.series, function (b) { var c = b.options; s(c.showInLegend, v(c.linkedTo) ? !1 : w, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b))) }); return a }, render: function () { var a = this, b = a.chart, c = b.renderer, d = a.group, e, f, g, h, k = a.box, l = a.options, m = a.padding, n = l.borderWidth, p = l.backgroundColor; a.itemX = a.initialItemX; a.itemY = a.initialItemY; a.offsetWidth = 0; a.lastItemY = 0; d || (a.group = d = c.g("legend").attr({ zIndex: 7 }).add(), a.contentGroup = c.g().attr({ zIndex: 1 }).add(d), a.scrollGroup = c.g().add(a.contentGroup)); a.renderTitle(); e = a.getAllItems(); tb(e, function (a, b) { return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0) }); l.reversed && e.reverse(); a.allItems = e; a.display = f = !!e.length; t(e, function (b) { a.renderItem(b) }); g = l.width || a.offsetWidth; h = a.lastItemY + a.lastLineHeight + a.titleHeight; h = a.handleOverflow(h); if (n || p) g += m, h += m, k ? 0 < g && 0 < h && (k[k.isNew ? "attr" : "animate"](k.crisp({ width: g, height: h })), k.isNew = !1) : (a.box = k = c.rect(0, 0, g, h, l.borderRadius, n || 0).attr({ stroke: l.borderColor, "stroke-width": n || 0, fill: p || V }).add(d).shadow(l.shadow), k.isNew = !0), k[f ? "show" : "hide"](); a.legendWidth = g; a.legendHeight = h; t(e, function (b) { a.positionItem(b) }); f && d.align(u({ width: g, height: h }, l), !0, "spacingBox"); b.isResizing || this.positionCheckboxes() }, handleOverflow: function (a) { var b = this, c = this.chart, d = c.renderer, e = this.options, f = e.y, f = c.spacingBox.height + ("top" === e.verticalAlign ? -f : f) - this.padding, g = e.maxHeight, h, k = this.clipRect, l = e.navigation, m = s(l.animation, !0), n = l.arrowSize || 12, p = this.nav, q = this.pages, r, u = this.allItems; "horizontal" === e.layout && (f /= 2); g && (f = F(f, g)); q.length = 0; a > f && !e.useHTML ? (this.clipHeight = h = x(f - 20 - this.titleHeight - this.padding, 0), this.currentPage = s(this.currentPage, 1), this.fullHeight = a, t(u, function (a, b) { var c = a._legendItemPos[1], d = y(a.legendItem.getBBox().height), e = q.length; if (!e || c - q[e - 1] > h && (r || c) !== q[e - 1]) q.push(r || c), e++; b === u.length - 1 && c + d - q[e - 1] > h && q.push(c); c !== r && (r = c) }), k || (k = b.clipRect = d.clipRect(0, this.padding, 9999, 0), b.contentGroup.clip(k)), k.attr({ height: h }), p || (this.nav = p = d.g().attr({ zIndex: 1 }).add(this.group), this.up = d.symbol("triangle", 0, 0, n, n).on("click", function () { b.scroll(-1, m) }).add(p), this.pager = d.text("", 15, 10).css(l.style).add(p), this.down = d.symbol("triangle-down", 0, 0, n, n).on("click", function () { b.scroll(1, m) }).add(p)), b.scroll(0), a = f) : p && (k.attr({ height: c.chartHeight }), p.hide(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0); return a }, scroll: function (a, b) { var c = this.pages, d = c.length, e = this.currentPage + a, f = this.clipHeight, g = this.options.navigation, h = g.activeColor, g = g.inactiveColor, k = this.pager, l = this.padding; e > d && (e = d); 0 < e && (b !== w && Ra(b, this.chart), this.nav.attr({ translateX: l, translateY: f + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ fill: 1 === e ? g : h }).css({ cursor: 1 === e ? "default" : "pointer" }), k.attr({ text: e + "/" + d }), this.down.attr({ x: 18 + this.pager.getBBox().width, fill: e === d ? g : h }).css({ cursor: e === d ? "default" : "pointer" }), c = -c[e - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: c }), this.currentPage = e, this.positionCheckboxes(c)) } }; var eb = J.LegendSymbolMixin = { drawRectangle: function (a, b) { var c = a.options.symbolHeight || 12; b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 5 - c / 2, a.symbolWidth, c, a.options.symbolRadius || 0).attr({ zIndex: 3 }).add(b.legendGroup) }, drawLineMarker: function (a) { var b = this.options, c = b.marker, d; d = a.symbolWidth; var e = this.chart.renderer, f = this.legendGroup; a = a.baseline - y(0.3 * e.fontMetrics(a.options.itemStyle.fontSize, this.legendItem).b); var g; b.lineWidth && (g = { "stroke-width": b.lineWidth }, b.dashStyle && (g.dashstyle = b.dashStyle), this.legendLine = e.path(["M", 0, a, "L", d, a]).attr(g).add(f)); c && !1 !== c.enabled && (b = c.radius, this.legendSymbol = d = e.symbol(this.symbol, d / 2 - b, a - b, 2 * b, 2 * b).add(f), d.isMarker = !0) } }; (/Trident\/7\.0/.test(wa) || Ua) && Na(pb.prototype, "positionItem", function (a, b) { var c = this, d = function () { b._legendItemPos && a.call(c, b) }; d(); setTimeout(d) }); Ya.prototype = { init: function (a, b) { var c, d = a.series; a.series = null; c = A(K, a); c.series = a.series = d; this.userOptions = a; d = c.chart; this.margin = this.splashArray("margin", d); this.spacing = this.splashArray("spacing", d); var e = d.events; this.bounds = { h: {}, v: {} }; this.callback = b; this.isResizing = 0; this.options = c; this.axes = []; this.series = []; this.hasCartesianSeries = d.showAxes; var f = this, g; f.index = X.length; X.push(f); ab++; !1 !== d.reflow && P(f, "load", function () { f.initReflow() }); if (e) for (g in e) P(f, g, e[g]); f.xAxis = []; f.yAxis = []; f.animation = ha ? !1 : s(d.animation, !0); f.pointCount = f.colorCounter = f.symbolCounter = 0; f.firstRender() }, initSeries: function (a) { var b = this.options.chart; (b = M[a.type || b.type || b.defaultSeriesType]) || pa(17, !0); b = new b; b.init(this, a); return b }, isInsidePlot: function (a, b, c) { var d = c ? b : a; a = c ? a : b; return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight }, adjustTickAmounts: function () { !1 !== this.options.chart.alignTicks && t(this.axes, function (a) { a.adjustTickAmount() }); this.maxTicks = null }, redraw: function (a) { var b = this.axes, c = this.series, d = this.pointer, e = this.legend, f = this.isDirtyLegend, g, h, k = this.hasCartesianSeries, l = this.isDirtyBox, m = c.length, n = m, p = this.renderer, q = p.isHidden(), r = []; Ra(a, this); q && this.cloneRenderTo(); for (this.layOutTitles() ; n--;) if (a = c[n], a.options.stacking && (g = !0, a.isDirty)) { h = !0; break } if (h) for (n = m; n--;) a = c[n], a.options.stacking && (a.isDirty = !0); t(c, function (a) { a.isDirty && "point" === a.options.legendType && (f = !0) }); f && e.options.enabled && (e.render(), this.isDirtyLegend = !1); g && this.getStacks(); k && (this.isResizing || (this.maxTicks = null, t(b, function (a) { a.setScale() })), this.adjustTickAmounts()); this.getMargins(); k && (t(b, function (a) { a.isDirty && (l = !0) }), t(b, function (a) { a.isDirtyExtremes && (a.isDirtyExtremes = !1, r.push(function () { N(a, "afterSetExtremes", u(a.eventArgs, a.getExtremes())); delete a.eventArgs })); (l || g) && a.redraw() })); l && this.drawChartBox(); t(c, function (a) { a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw() }); d && d.reset(!0); p.draw(); N(this, "redraw"); q && this.cloneRenderTo(!0); t(r, function (a) { a.call() }) }, get: function (a) { var b = this.axes, c = this.series, d, e; for (d = 0; d < b.length; d++) if (b[d].options.id === a) return b[d]; for (d = 0; d < c.length; d++) if (c[d].options.id === a) return c[d]; for (d = 0; d < c.length; d++) for (e = c[d].points || [], b = 0; b < e.length; b++) if (e[b].id === a) return e[b]; return null }, getAxes: function () { var a = this, b = this.options, c = b.xAxis = ra(b.xAxis || {}), b = b.yAxis = ra(b.yAxis || {}); t(c, function (a, b) { a.index = b; a.isX = !0 }); t(b, function (a, b) { a.index = b }); c = c.concat(b); t(c, function (b) { new na(a, b) }); a.adjustTickAmounts() }, getSelectedPoints: function () { var a = []; t(this.series, function (b) { a = a.concat(Bb(b.points || [], function (a) { return a.selected })) }); return a }, getSelectedSeries: function () { return Bb(this.series, function (a) { return a.selected }) }, getStacks: function () { var a = this; t(a.yAxis, function (a) { a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks) }); t(a.series, function (b) { !b.options.stacking || !0 !== b.visible && !1 !== a.options.chart.ignoreHiddenSeries || (b.stackKey = b.type + s(b.options.stack, "")) }) }, setTitle: function (a, b, c) { var d = this, e = d.options, f; f = e.title = A(e.title, a); e = e.subtitle = A(e.subtitle, b); t([["title", a, f], ["subtitle", b, e]], function (a) { var b = a[0], c = d[b], e = a[1]; a = a[2]; c && e && (d[b] = c = c.destroy()); a && a.text && !c && (d[b] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({ align: a.align, "class": "highcharts-" + b, zIndex: a.zIndex || 4 }).css(a.style).add()) }); d.layOutTitles(c) }, layOutTitles: function (a) { var b = 0, c = this.title, d = this.subtitle, e = this.options, f = e.title, e = e.subtitle, g = this.renderer, h = this.spacingBox.width - 44; c && (c.css({ width: (f.width || h) + "px" }).align(u({ y: g.fontMetrics(f.style.fontSize, c).b - 3 }, f), !1, "spacingBox"), f.floating || f.verticalAlign || (b = c.getBBox().height)); d && (d.css({ width: (e.width || h) + "px" }).align(u({ y: b + (f.margin - 13) + g.fontMetrics(f.style.fontSize, d).b }, e), !1, "spacingBox"), e.floating || e.verticalAlign || (b = La(b + d.getBBox().height))); c = this.titleOffset !== b; this.titleOffset = b; !this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && s(a, !0) && this.isDirtyBox && this.redraw()) }, getChartSize: function () { var a = this.options.chart, b = a.width, a = a.height, c = this.renderToClone || this.renderTo; v(b) || (this.containerWidth = mb(c, "width")); v(a) || (this.containerHeight = mb(c, "height")); this.chartWidth = x(0, b || this.containerWidth || 600); this.chartHeight = x(0, s(a, 19 < this.containerHeight ? this.containerHeight : 400)) }, cloneRenderTo: function (a) { var b = this.renderToClone, c = this.container; a ? b && (this.renderTo.appendChild(c), Qa(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), D(b, { position: "absolute", top: "-9999px", display: "block" }), b.style.setProperty && b.style.setProperty("display", "block", "important"), z.body.appendChild(b), c && b.appendChild(c)) }, getContainer: function () { var a, b = this.options.chart, c, d, e; this.renderTo = a = b.renderTo; e = "highcharts-" + zb++; Ga(a) && (this.renderTo = a = z.getElementById(a)); a || pa(13, !0); c = C(R(a, "data-highcharts-chart")); !isNaN(c) && X[c] && X[c].hasRendered && X[c].destroy(); R(a, "data-highcharts-chart", this.index); a.innerHTML = ""; b.skipClone || a.offsetWidth || this.cloneRenderTo(); this.getChartSize(); c = this.chartWidth; d = this.chartHeight; this.container = a = aa(Ka, { className: "highcharts-container" + (b.className ? " " + b.className : ""), id: e }, u({ position: "relative", overflow: "hidden", width: c + "px", height: d + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, b.style), this.renderToClone || a); this._cursor = a.style.cursor; this.renderer = b.forExport ? new ta(a, c, d, b.style, !0) : new Za(a, c, d, b.style); ha && this.renderer.create(this, a, c, d) }, getMargins: function () { var a = this.spacing, b, c = this.legend, d = this.margin, e = this.options.legend, f = s(e.margin, 20), g = e.x, h = e.y, k = e.align, l = e.verticalAlign, m = this.titleOffset; this.resetMargins(); b = this.axisOffset; m && !v(d[0]) && (this.plotTop = x(this.plotTop, m + this.options.title.margin + a[0])); c.display && !e.floating && ("right" === k ? v(d[1]) || (this.marginRight = x(this.marginRight, c.legendWidth - g + f + a[1])) : "left" === k ? v(d[3]) || (this.plotLeft = x(this.plotLeft, c.legendWidth + g + f + a[3])) : "top" === l ? v(d[0]) || (this.plotTop = x(this.plotTop, c.legendHeight + h + f + a[0])) : "bottom" !== l || v(d[2]) || (this.marginBottom = x(this.marginBottom, c.legendHeight - h + f + a[2]))); this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin); this.extraTopMargin && (this.plotTop += this.extraTopMargin); this.hasCartesianSeries && t(this.axes, function (a) { a.getOffset() }); v(d[3]) || (this.plotLeft += b[3]); v(d[0]) || (this.plotTop += b[0]); v(d[2]) || (this.marginBottom += b[2]); v(d[1]) || (this.marginRight += b[1]); this.setChartSize() }, reflow: function (a) { var b = this, c = b.options.chart, d = b.renderTo, e = c.width || mb(d, "width"), f = c.height || mb(d, "height"), c = a ? a.target : I, d = function () { b.container && (b.setSize(e, f, !1), b.hasUserSize = null) }; if (!b.hasUserSize && e && f && (c === I || c === z)) { if (e !== b.containerWidth || f !== b.containerHeight) clearTimeout(b.reflowTimeout), a ? b.reflowTimeout = setTimeout(d, 100) : d(); b.containerWidth = e; b.containerHeight = f } }, initReflow: function () { var a = this, b = function (b) { a.reflow(b) }; P(I, "resize", b); P(a, "destroy", function () { Y(I, "resize", b) }) }, setSize: function (a, b, c) { var d = this, e, f, g; d.isResizing += 1; g = function () { d && N(d, "endResize", null, function () { d.isResizing -= 1 }) }; Ra(c, d); d.oldChartHeight = d.chartHeight; d.oldChartWidth = d.chartWidth; v(a) && (d.chartWidth = e = x(0, y(a)), d.hasUserSize = !!e); v(b) && (d.chartHeight = f = x(0, y(b))); (va ? nb : D)(d.container, { width: e + "px", height: f + "px" }, va); d.setChartSize(!0); d.renderer.setSize(e, f, c); d.maxTicks = null; t(d.axes, function (a) { a.isDirty = !0; a.setScale() }); t(d.series, function (a) { a.isDirty = !0 }); d.isDirtyLegend = !0; d.isDirtyBox = !0; d.layOutTitles(); d.getMargins(); d.redraw(c); d.oldChartHeight = null; N(d, "resize"); !1 === va ? g() : setTimeout(g, va && va.duration || 500) }, setChartSize: function (a) { var b = this.inverted, c = this.renderer, d = this.chartWidth, e = this.chartHeight, f = this.options.chart, g = this.spacing, h = this.clipOffset, k, l, m, n; this.plotLeft = k = y(this.plotLeft); this.plotTop = l = y(this.plotTop); this.plotWidth = m = x(0, y(d - k - this.marginRight)); this.plotHeight = n = x(0, y(e - l - this.marginBottom)); this.plotSizeX = b ? n : m; this.plotSizeY = b ? m : n; this.plotBorderWidth = f.plotBorderWidth || 0; this.spacingBox = c.spacingBox = { x: g[3], y: g[0], width: d - g[3] - g[1], height: e - g[0] - g[2] }; this.plotBox = c.plotBox = { x: k, y: l, width: m, height: n }; d = 2 * U(this.plotBorderWidth / 2); b = La(x(d, h[3]) / 2); c = La(x(d, h[0]) / 2); this.clipBox = { x: b, y: c, width: U(this.plotSizeX - x(d, h[1]) / 2 - b), height: x(0, U(this.plotSizeY - x(d, h[2]) / 2 - c)) }; a || t(this.axes, function (a) { a.setAxisSize(); a.setAxisTranslation() }) }, resetMargins: function () { var a = this.spacing, b = this.margin; this.plotTop = s(b[0], a[0]); this.marginRight = s(b[1], a[1]); this.marginBottom = s(b[2], a[2]); this.plotLeft = s(b[3], a[3]); this.axisOffset = [0, 0, 0, 0]; this.clipOffset = [0, 0, 0, 0] }, drawChartBox: function () { var a = this.options.chart, b = this.renderer, c = this.chartWidth, d = this.chartHeight, e = this.chartBackground, f = this.plotBackground, g = this.plotBorder, h = this.plotBGImage, k = a.borderWidth || 0, l = a.backgroundColor, m = a.plotBackgroundColor, n = a.plotBackgroundImage, p = a.plotBorderWidth || 0, q, r = this.plotLeft, s = this.plotTop, t = this.plotWidth, u = this.plotHeight, x = this.plotBox, v = this.clipRect, y = this.clipBox; q = k + (a.shadow ? 8 : 0); if (k || l) e ? e.animate(e.crisp({ width: c - q, height: d - q })) : (e = { fill: l || V }, k && (e.stroke = a.borderColor, e["stroke-width"] = k), this.chartBackground = b.rect(q / 2, q / 2, c - q, d - q, a.borderRadius, k).attr(e).addClass("highcharts-background").add().shadow(a.shadow)); m && (f ? f.animate(x) : this.plotBackground = b.rect(r, s, t, u, 0).attr({ fill: m }).add().shadow(a.plotShadow)); n && (h ? h.animate(x) : this.plotBGImage = b.image(n, r, s, t, u).add()); v ? v.animate({ width: y.width, height: y.height }) : this.clipRect = b.clipRect(y); p && (g ? g.animate(g.crisp({ x: r, y: s, width: t, height: u })) : this.plotBorder = b.rect(r, s, t, u, 0, -p).attr({ stroke: a.plotBorderColor, "stroke-width": p, fill: V, zIndex: 1 }).add()); this.isDirtyBox = !1 }, propFromSeries: function () { var a = this, b = a.options.chart, c, d = a.options.series, e, f; t(["inverted", "angular", "polar"], function (g) { c = M[b.type || b.defaultSeriesType]; f = a[g] || b[g] || c && c.prototype[g]; for (e = d && d.length; !f && e--;) (c = M[d[e].type]) && c.prototype[g] && (f = !0); a[g] = f }) }, linkSeries: function () { var a = this, b = a.series; t(b, function (a) { a.linkedSeries.length = 0 }); t(b, function (b) { var d = b.options.linkedTo; Ga(d) && (d = ":previous" === d ? a.series[b.index - 1] : a.get(d)) && (d.linkedSeries.push(b), b.linkedParent = d) }) }, renderSeries: function () { t(this.series, function (a) { a.translate(); a.setTooltipPoints && a.setTooltipPoints(); a.render() }) }, renderLabels: function () { var a = this, b = a.options.labels; b.items && t(b.items, function (c) { var d = u(b.style, c.style), e = C(d.left) + a.plotLeft, f = C(d.top) + a.plotTop + 12; delete d.left; delete d.top; a.renderer.text(c.html, e, f).attr({ zIndex: 2 }).css(d).add() }) }, render: function () { var a = this.axes, b = this.renderer, c = this.options; this.setTitle(); this.legend = new pb(this, c.legend); this.getStacks(); t(a, function (a) { a.setScale() }); this.getMargins(); this.maxTicks = null; t(a, function (a) { a.setTickPositions(!0); a.setMaxTicks() }); this.adjustTickAmounts(); this.getMargins(); this.drawChartBox(); this.hasCartesianSeries && t(a, function (a) { a.render() }); this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({ zIndex: 3 }).add()); this.renderSeries(); this.renderLabels(); this.showCredits(c.credits); this.hasRendered = !0 }, showCredits: function (a) { a.enabled && !this.credits && (this.credits = this.renderer.text(a.text, 0, 0).on("click", function () { a.href && (location.href = a.href) }).attr({ align: a.position.align, zIndex: 8 }).css(a.style).add().align(a.position)) }, destroy: function () { var a = this, b = a.axes, c = a.series, d = a.container, e, f = d && d.parentNode; N(a, "destroy"); X[a.index] = w; ab--; a.renderTo.removeAttribute("data-highcharts-chart"); Y(a); for (e = b.length; e--;) b[e] = b[e].destroy(); for (e = c.length; e--;) c[e] = c[e].destroy(); t("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer scroller rangeSelector legend resetZoomButton tooltip renderer".split(" "), function (b) { var c = a[b]; c && c.destroy && (a[b] = c.destroy()) }); d && (d.innerHTML = "", Y(d), f && Qa(d)); for (e in a) delete a[e] }, isReadyToRender: function () { var a = this; return !ca && I == I.top && "complete" !== z.readyState || ha && !I.canvg ? (ha ? Xb.push(function () { a.firstRender() }, a.options.global.canvasToolsURL) : z.attachEvent("onreadystatechange", function () { z.detachEvent("onreadystatechange", a.firstRender); "complete" === z.readyState && a.firstRender() }), !1) : !0 }, firstRender: function () { var a = this, b = a.options, c = a.callback; a.isReadyToRender() && (a.getContainer(), N(a, "init"), a.resetMargins(), a.setChartSize(), a.propFromSeries(), a.getAxes(), t(b.series || [], function (b) { a.initSeries(b) }), a.linkSeries(), N(a, "beforeRender"), J.Pointer && (a.pointer = new Wa(a, b)), a.render(), a.renderer.draw(), c && c.apply(a, [a]), t(a.callbacks, function (b) { b.apply(a, [a]) }), a.cloneRenderTo(!0), N(a, "load")) }, splashArray: function (a, b) { var c = b[a], c = ea(c) ? c : [c, c, c, c]; return [s(b[a + "Top"], c[0]), s(b[a + "Right"], c[1]), s(b[a + "Bottom"], c[2]), s(b[a + "Left"], c[3])] } }; Ya.prototype.callbacks = []; var mc = J.CenteredSeriesMixin = { getCenter: function () { var a = this.options, b = this.chart, c = 2 * (a.slicedOffset || 0), d, e = b.plotWidth - 2 * c, f = b.plotHeight - 2 * c, b = a.center, a = [s(b[0], "50%"), s(b[1], "50%"), a.size || "100%", a.innerSize || 0], g = F(e, f), h; return Va(a, function (a, b) { h = /%$/.test(a); d = 2 > b || 2 === b && h; return (h ? [e, f, g, g][b] * C(a) / 100 : a) + (d ? c : 0) }) } }, Fa = function () { }; Fa.prototype = { init: function (a, b, c) { this.series = a; this.applyOptions(b, c); this.pointAttr = {}; a.options.colorByPoint && (b = a.options.colors || a.chart.options.colors, this.color = this.color || b[a.colorCounter++], a.colorCounter === b.length && (a.colorCounter = 0)); a.chart.pointCount++; return this }, applyOptions: function (a, b) { var c = this.series, d = c.options.pointValKey || c.pointValKey; a = Fa.prototype.optionsToObject.call(this, a); u(this, a); this.options = this.options ? u(this.options, a) : a; d && (this.y = this[d]); this.x === w && c && (this.x = b === w ? c.autoIncrement() : b); return this }, optionsToObject: function (a) { var b = {}, c = this.series, d = c.pointArrayMap || ["y"], e = d.length, f = 0, g = 0; if ("number" === typeof a || null === a) b[d[0]] = a; else if (Ma(a)) for (a.length > e && (c = typeof a[0], "string" === c ? b.name = a[0] : "number" === c && (b.x = a[0]), f++) ; g < e;) b[d[g++]] = a[f++]; else "object" === typeof a && (b = a, a.dataLabels && (c._hasPointLabels = !0), a.marker && (c._hasPointMarkers = !0)); return b }, destroy: function () { var a = this.series.chart, b = a.hoverPoints, c; a.pointCount--; b && (this.setState(), la(b, this), b.length || (a.hoverPoints = null)); if (this === a.hoverPoint) this.onMouseOut(); if (this.graphic || this.dataLabel) Y(this), this.destroyElements(); this.legendItem && a.legend.destroyItem(this); for (c in this) this[c] = null }, destroyElements: function () { for (var a = "graphic dataLabel dataLabelUpper group connector shadowGroup".split(" "), b, c = 6; c--;) b = a[c], this[b] && (this[b] = this[b].destroy()) }, getLabelConfig: function () { return { x: this.category, y: this.y, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal } }, tooltipFormatter: function (a) { var b = this.series, c = b.tooltipOptions, d = s(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || ""; t(b.pointArrayMap || ["y"], function (b) { b = "{point." + b; if (e || f) a = a.replace(b + "}", e + b + "}" + f); a = a.replace(b + "}", b + ":,." + d + "f}") }); return Ja(a, { point: this, series: this.series }) }, firePointEvent: function (a, b, c) { var d = this, e = this.series.options; (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents(); "click" === a && e.allowPointSelect && (c = function (a) { d.select(null, a.ctrlKey || a.metaKey || a.shiftKey) }); N(this, a, b, c) } }; var Q = function () { }; Q.prototype = { isCartesian: !0, type: "line", pointClass: Fa, sorted: !0, requireSorting: !0, pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius" }, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], init: function (a, b) { var c = this, d, e, f = a.series, g = function (a, b) { return s(a.options.index, a._i) - s(b.options.index, b._i) }; c.chart = a; c.options = b = c.setOptions(b); c.linkedSeries = []; c.bindAxes(); u(c, { name: b.name, state: "", pointAttr: {}, visible: !1 !== b.visible, selected: !0 === b.selected }); ha && (b.animation = !1); e = b.events; for (d in e) c.userData = $.extend(!0, {}, b.data), P(c, d, e[d]); if (e && e.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0; c.getColor(); c.getSymbol(); t(c.parallelArrays, function (a) { c[a + "Data"] = [] }); c.setData(b.data, !1); c.isCartesian && (a.hasCartesianSeries = !0); f.push(c); c._i = f.length - 1; tb(f, g); this.yAxis && tb(this.yAxis.series, g); t(f, function (a, b) { a.index = b; a.name = a.name || "Series " + (b + 1) }) }, bindAxes: function () { var a = this, b = a.options, c = a.chart, d; t(a.axisTypes || [], function (e) { t(c[e], function (c) { d = c.options; if (b[e] === d.index || b[e] !== w && b[e] === d.id || b[e] === w && 0 === d.index) c.series.push(a), a[e] = c, c.isDirty = !0 }); a[e] || a.optionalAxis === e || pa(18, !0) }) }, updateParallelArrays: function (a, b) { var c = a.series, d = arguments; t(c.parallelArrays, "number" === typeof b ? function (d) { var f = "y" === d && c.toYData ? c.toYData(a) : a[d]; c[d + "Data"][b] = f } : function (a) { Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2)) }) }, autoIncrement: function () { var a = this.options, b = this.xIncrement, b = s(b, a.pointStart, 0); this.pointInterval = s(this.pointInterval, a.pointInterval, 1); this.xIncrement = b + this.pointInterval; return b }, getSegments: function () { var a = -1, b = [], c, d = this.points, e = d.length; if (e) if (this.options.connectNulls) { for (c = e; c--;) null === d[c].y && d.splice(c, 1); d.length && (b = [d]) } else t(d, function (c, g) { null === c.y ? (g > a + 1 && b.push(d.slice(a + 1, g)), a = g) : g === e - 1 && b.push(d.slice(a + 1, g + 1)) }); this.segments = b }, setOptions: function (a) { var b = this.chart, c = b.options.plotOptions, b = b.userOptions || {}, d = b.plotOptions || {}, e = c[this.type]; this.userOptions = a; c = A(e, c.series, a); this.tooltipOptions = A(K.tooltip, K.plotOptions[this.type].tooltip, b.tooltip, d.series && d.series.tooltip, d[this.type] && d[this.type].tooltip, a.tooltip); null === e.marker && delete c.marker; return c }, getCyclic: function (a, b, c) { var d = this.userOptions, e = "_" + a + "Index", f = a + "Counter"; b || (v(d[e]) ? b = d[e] : (d[e] = b = this.chart[f] % c.length, this.chart[f] += 1), b = c[b]); this[a] = b }, getColor: function () { this.options.colorByPoint || this.getCyclic("color", this.options.color || da[this.type].color, this.chart.options.colors) }, getSymbol: function () { var a = this.options.marker; this.getCyclic("symbol", a.symbol, this.chart.options.symbols); /^url/.test(this.symbol) && (a.radius = 0) }, drawLegendSymbol: eb.drawLineMarker, setData: function (a, b, c, d) { var e = this, f = e.points, g = f && f.length || 0, h, k = e.options, l = e.chart, m = null, n = e.xAxis, p = n && !!n.categories, q = e.tooltipPoints, r = k.turboThreshold, u = this.xData, x = this.yData, y = (h = e.pointArrayMap) && h.length; a = a || []; h = a.length; b = s(b, !0); if (!1 === d || !h || g !== h || e.cropped || e.hasGroupedData) { e.xIncrement = null; e.pointRange = p ? 1 : k.pointRange; e.colorCounter = 0; t(this.parallelArrays, function (a) { e[a + "Data"].length = 0 }); if (r && h > r) { for (c = 0; null === m && c < h;) m = a[c], c++; if (ja(m)) { p = s(k.pointStart, 0); k = s(k.pointInterval, 1); for (c = 0; c < h; c++) u[c] = p, x[c] = a[c], p += k; e.xIncrement = p } else if (Ma(m)) if (y) for (c = 0; c < h; c++) k = a[c], u[c] = k[0], x[c] = k.slice(1, y + 1); else for (c = 0; c < h; c++) k = a[c], u[c] = k[0], x[c] = k[1]; else pa(12) } else for (c = 0; c < h; c++) a[c] !== w && (k = { series: e }, e.pointClass.prototype.applyOptions.apply(k, [a[c]]), e.updateParallelArrays(k, c), p && k.name && (n.names[k.x] = k.name)); Ga(x[0]) && pa(14, !0); e.data = []; e.options.data = a; for (c = g; c--;) f[c] && f[c].destroy && f[c].destroy(); q && (q.length = 0); n && (n.minRange = n.userMinRange); e.isDirty = e.isDirtyData = l.isDirtyBox = !0; c = !1 } else t(a, function (a, b) { f[b].update(a, !1) }); b && l.redraw(c) }, processData: function (a) { var b = this.xData, c = this.yData, d = b.length, e; e = 0; var f, g, h = this.xAxis, k = this.options, l = k.cropThreshold, m = 0, n = this.isCartesian, p, q; if (n && !(this.isDirty || h.isDirty || this.yAxis.isDirty || a)) return !1; if (n && this.sorted && (!l || d > l || this.forceCrop)) if (p = h.getExtremes(), q = p.min, p = p.max, b[d - 1] < q || b[0] > p) b = [], c = []; else if (b[0] < q || b[d - 1] > p) e = this.cropData(this.xData, this.yData, q, p), b = e.xData, c = e.yData, e = e.start, f = !0, m = b.length; for (a = b.length - 1; 0 <= a; a--) d = b[a] - b[a - 1], !f && b[a] > q && b[a] < p && m++, 0 < d && (g === w || d < g) ? g = d : 0 > d && this.requireSorting && pa(15); this.cropped = f; this.cropStart = e; this.processedXData = b; this.processedYData = c; this.activePointCount = m; null === k.pointRange && (this.pointRange = g || 1); this.closestPointRange = g }, cropData: function (a, b, c, d) { var e = a.length, f = 0, g = e, h = s(this.cropShoulder, 1), k; for (k = 0; k < e; k++) if (a[k] >= c) { f = x(0, k - h); break } for (; k < e; k++) if (a[k] > d) { g = k + h; break } return { xData: a.slice(f, g), yData: b.slice(f, g), start: f, end: g } }, generatePoints: function () { var a = this.options.data, b = this.data, c, d = this.processedXData, e = this.processedYData, f = this.pointClass, g = d.length, h = this.cropStart || 0, k, l = this.hasGroupedData, m, n = [], p; b || l || (b = [], b.length = a.length, b = this.data = b); for (p = 0; p < g; p++) k = h + p, l ? n[p] = (new f).init(this, [d[p]].concat(ra(e[p]))) : (b[k] ? m = b[k] : a[k] !== w && (b[k] = m = (new f).init(this, a[k], d[p])), n[p] = m); if (b && (g !== (c = b.length) || l)) for (p = 0; p < c; p++) p !== h || l || (p += g), b[p] && (b[p].destroyElements(), b[p].plotX = w); this.data = b; this.points = n }, getExtremes: function (a) { var b = this.yAxis, c = this.processedXData, d, e = [], f = 0; d = this.xAxis.getExtremes(); var g = d.min, h = d.max, k, l, m, n; a = a || this.stackedYData || this.processedYData; d = a.length; for (n = 0; n < d; n++) if (l = c[n], m = a[n], k = null !== m && m !== w && (!b.isLog || m.length || 0 < m), l = this.getExtremesFromAll || this.cropped || (c[n + 1] || l) >= g && (c[n - 1] || l) <= h, k && l) if (k = m.length) for (; k--;) null !== m[k] && (e[f++] = m[k]); else e[f++] = m; this.dataMin = s(void 0, Oa(e)); this.dataMax = s(void 0, Ba(e)) }, translate: function () { this.processedXData || this.processData(); this.generatePoints(); for (var a = this.options, b = a.stacking, c = this.xAxis, d = c.categories, e = this.yAxis, f = this.points, g = f.length, h = !!this.modifyValue, k = a.pointPlacement, l = "between" === k || ja(k), m = a.threshold, a = 0; a < g; a++) { var n = f[a], p = n.x, q = n.y, r = n.low, t = b && e.stacks[(this.negStacks && q < m ? "-" : "") + this.stackKey]; e.isLog && 0 >= q && (n.y = q = null); n.plotX = c.translate(p, 0, 0, 0, 1, k, "flags" === this.type); b && this.visible && t && t[p] && (t = t[p], q = t.points[this.index + "," + a], r = q[0], q = q[1], 0 === r && (r = s(m, e.min)), e.isLog && 0 >= r && (r = null), n.total = n.stackTotal = t.total, n.percentage = t.total && 100 * (n.y / t.total), n.stackY = q, t.setOffset(this.pointXOffset || 0, this.barW || 0)); n.yBottom = v(r) ? e.translate(r, 0, 1, 0, 1) : null; h && (q = this.modifyValue(q, n)); n.plotY = "number" === typeof q && Infinity !== q ? e.translate(q, 0, 1, 0, 1) : w; n.clientX = l ? c.translate(p, 0, 0, 0, 1) : n.plotX; n.negative = n.y < (m || 0); n.category = d && d[n.x] !== w ? d[n.x] : n.x } this.getSegments() }, animate: function (a) { var b = this.chart, c = b.renderer, d; d = this.options.animation; var e = this.clipBox || b.clipBox, f = b.inverted, g; d && !ea(d) && (d = da[this.type].animation); g = ["_sharedClip", d.duration, d.easing, e.height].join(); a ? (a = b[g], d = b[g + "m"], a || (b[g] = a = c.clipRect(u(e, { width: 0 })), b[g + "m"] = d = c.clipRect(-99, f ? -b.plotLeft : -b.plotTop, 99, f ? b.chartWidth : b.chartHeight)), this.group.clip(a), this.markerGroup.clip(d), this.sharedClipKey = g) : ((a = b[g]) && a.animate({ width: b.plotSizeX }, d), b[g + "m"] && b[g + "m"].animate({ width: b.plotSizeX + 99 }, d), this.animate = null) }, afterAnimate: function () { var a = this.chart, b = this.sharedClipKey, c = this.group, d = this.clipBox; c && !1 !== this.options.clip && (b && d || c.clip(d ? a.renderer.clipRect(d) : a.clipRect), this.markerGroup.clip()); N(this, "afterAnimate"); setTimeout(function () { b && a[b] && (d || (a[b] = a[b].destroy()), a[b + "m"] && (a[b + "m"] = a[b + "m"].destroy())) }, 100) }, drawPoints: function () { var a, b = this.points, c = this.chart, d, e, f, g, h, k, l, m; d = this.options.marker; var n = this.pointAttr[""], p, q = this.markerGroup, r = s(d.enabled, this.activePointCount < 0.5 * this.xAxis.len / d.radius); if (!1 !== d.enabled || this._hasPointMarkers) for (f = b.length; f--;) g = b[f], d = U(g.plotX), e = g.plotY, m = g.graphic, k = g.marker || {}, a = r && k.enabled === w || k.enabled, p = c.isInsidePlot(y(d), e, c.inverted), a && e !== w && !isNaN(e) && null !== g.y ? (a = g.pointAttr[g.selected ? "select" : ""] || n, h = a.r, k = s(k.symbol, this.symbol), l = 0 === k.indexOf("url"), m ? m[p ? "show" : "hide"](!0).animate(u({ x: d - h, y: e - h }, m.symbolName ? { width: 2 * h, height: 2 * h } : {})) : p && (0 < h || l) && (g.graphic = c.renderer.symbol(k, d - h, e - h, 2 * h, 2 * h).attr(a).add(q))) : m && (g.graphic = m.destroy()) }, convertAttribs: function (a, b, c, d) { var e = this.pointAttrToOptions, f, g, h = {}; a = a || {}; b = b || {}; c = c || {}; d = d || {}; for (f in e) g = e[f], h[f] = s(a[g], b[f], c[f], d[f]); return h }, getAttribs: function () { var a = this, b = a.options, c = da[a.type].marker ? b.marker : b, d = c.states, e = d.hover, f, g = a.color; f = { stroke: g, fill: g }; var h = a.points || [], k, l = [], m, n = a.pointAttrToOptions; m = a.hasPointSpecificOptions; var p = b.negativeColor, q = c.lineColor, r = c.fillColor; k = b.turboThreshold; var s; b.marker ? (e.radius = e.radius || c.radius + e.radiusPlus, e.lineWidth = e.lineWidth || c.lineWidth + e.lineWidthPlus) : e.color = e.color || ya(e.color || g).brighten(e.brightness).get(); l[""] = a.convertAttribs(c, f); t(["hover", "select"], function (b) { l[b] = a.convertAttribs(d[b], l[""]) }); a.pointAttr = l; g = h.length; if (!k || g < k || m) for (; g--;) { k = h[g]; (c = k.options && k.options.marker || k.options) && !1 === c.enabled && (c.radius = 0); k.negative && p && (k.color = k.fillColor = p); m = b.colorByPoint || k.color; if (k.options) for (s in n) v(c[n[s]]) && (m = !0); m ? (c = c || {}, m = [], d = c.states || {}, f = d.hover = d.hover || {}, b.marker || (f.color = f.color || !k.options.color && e.color || ya(k.color).brighten(f.brightness || e.brightness).get()), f = { color: k.color }, r || (f.fillColor = k.color), q || (f.lineColor = k.color), m[""] = a.convertAttribs(u(f, c), l[""]), m.hover = a.convertAttribs(d.hover, l.hover, m[""]), m.select = a.convertAttribs(d.select, l.select, m[""])) : m = l; k.pointAttr = m } }, destroy: function () { var a = this, b = a.chart, c = /AppleWebKit\/533/.test(wa), d, e, f = a.data || [], g, h, k; N(a, "destroy"); Y(a); t(a.axisTypes || [], function (b) { if (k = a[b]) la(k.series, a), k.isDirty = k.forceRedraw = !0 }); a.legendItem && a.chart.legend.destroyItem(a); for (e = f.length; e--;) (g = f[e]) && g.destroy && g.destroy(); a.points = null; clearTimeout(a.animationTimeout); t("area graph dataLabelsGroup group markerGroup tracker graphNeg areaNeg posClip negClip".split(" "), function (b) { a[b] && (d = c && "group" === b ? "hide" : "destroy", a[b][d]()) }); b.hoverSeries === a && (b.hoverSeries = null); la(b.series, a); for (h in a) delete a[h] }, getSegmentPath: function (a) { var b = this, c = [], d = b.options.step; t(a, function (e, f) { var g = e.plotX, h = e.plotY, k; b.getPointSpline ? c.push.apply(c, b.getPointSpline(a, e, f)) : (c.push(f ? "L" : "M"), d && f && (k = a[f - 1], "right" === d ? c.push(k.plotX, h) : "center" === d ? c.push((k.plotX + g) / 2, k.plotY, (k.plotX + g) / 2, h) : c.push(g, k.plotY)), c.push(e.plotX, e.plotY)) }); return c }, getGraphPath: function () { var a = this, b = [], c, d = []; t(a.segments, function (e) { c = a.getSegmentPath(e); 1 < e.length ? b = b.concat(c) : d.push(e[0]) }); a.singlePoints = d; return a.graphPath = b }, drawGraph: function () { var a = this, b = this.options, c = [["graph", b.lineColor || this.color]], d = b.lineWidth, e = b.dashStyle, f = "square" !== b.linecap, g = this.getGraphPath(), h = b.negativeColor; h && c.push(["graphNeg", h]); t(c, function (c, h) { var m = c[0], n = a[m]; n ? (cb(n), n.animate({ d: g })) : d && g.length && (n = { stroke: c[1], "stroke-width": d, fill: V, zIndex: 1 }, e ? n.dashstyle = e : f && (n["stroke-linecap"] = n["stroke-linejoin"] = "round"), a[m] = a.chart.renderer.path(g).attr(n).add(a.group).shadow(!h && b.shadow)) }) }, clipNeg: function () { var a = this.options, b = this.chart, c = b.renderer, d = a.negativeColor || a.negativeFillColor, e, f = this.graph, g = this.area, h = this.posClip, k = this.negClip; e = b.chartWidth; var l = b.chartHeight, m = x(e, l), n = this.yAxis; d && (f || g) && (d = y(n.toPixels(a.threshold || 0, !0)), 0 > d && (m -= d), a = { x: 0, y: 0, width: m, height: d }, m = { x: 0, y: d, width: m, height: m }, b.inverted && (a.height = m.y = b.plotWidth - d, c.isVML && (a = { x: b.plotWidth - d - b.plotLeft, y: 0, width: e, height: l }, m = { x: d + b.plotLeft - e, y: 0, width: b.plotLeft + d, height: e })), n.reversed ? (b = m, e = a) : (b = a, e = m), h ? (h.animate(b), k.animate(e)) : (this.posClip = h = c.clipRect(b), this.negClip = k = c.clipRect(e), f && this.graphNeg && (f.clip(h), this.graphNeg.clip(k)), g && (g.clip(h), this.areaNeg.clip(k)))) }, invertGroups: function () { function a() { var a = { width: b.yAxis.len, height: b.xAxis.len }; t(["group", "markerGroup"], function (c) { b[c] && b[c].attr(a).invert() }) } var b = this, c = b.chart; b.xAxis && (P(c, "resize", a), P(b, "destroy", function () { Y(c, "resize", a) }), a(), b.invertGroups = a) }, plotGroup: function (a, b, c, d, e) { var f = this[a], g = !f; g && (this[a] = f = this.chart.renderer.g(b).attr({ visibility: c, zIndex: d || 0.1 }).add(e)); f[g ? "attr" : "animate"](this.getPlotBox()); return f }, getPlotBox: function () { var a = this.chart, b = this.xAxis, c = this.yAxis; a.inverted && (b = c, c = this.xAxis); return { translateX: b ? b.left : a.plotLeft, translateY: c ? c.top : a.plotTop, scaleX: 1, scaleY: 1 } }, render: function () { var a = this, b = a.chart, c, d = a.options, e = (c = d.animation) && !!a.animate && b.renderer.isSVG && s(c.duration, 500) || 0, f = a.visible ? "visible" : "hidden", g = d.zIndex, h = a.hasRendered, k = b.seriesGroup; c = a.plotGroup("group", "series", f, g, k); a.markerGroup = a.plotGroup("markerGroup", "markers", f, g, k); e && a.animate(!0); a.getAttribs(); c.inverted = a.isCartesian ? b.inverted : !1; a.drawGraph && (a.drawGraph(), a.clipNeg()); a.drawDataLabels && a.drawDataLabels(); a.visible && a.drawPoints(); a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker(); b.inverted && a.invertGroups(); !1 === d.clip || a.sharedClipKey || h || c.clip(b.clipRect); e && a.animate(); h || (e ? a.animationTimeout = setTimeout(function () { a.afterAnimate() }, e) : a.afterAnimate()); a.isDirty = a.isDirtyData = !1; a.hasRendered = !0 }, redraw: function () { var a = this.chart, b = this.isDirtyData, c = this.group, d = this.xAxis, e = this.yAxis; c && (a.inverted && c.attr({ width: a.plotWidth, height: a.plotHeight }), c.animate({ translateX: s(d && d.left, a.plotLeft), translateY: s(e && e.top, a.plotTop) })); this.translate(); this.setTooltipPoints && this.setTooltipPoints(!0); this.render(); b && N(this, "updatedData") } }; Rb.prototype = { destroy: function () { Pa(this, this.axis) }, render: function (a) { var b = this.options, c = b.format, c = c ? Ja(c, this) : b.formatter.call(this); this.label ? this.label.attr({ text: c, visibility: "hidden" }) : this.label = this.axis.chart.renderer.text(c, null, null, b.useHTML).css(b.style).attr({ align: this.textAlign, rotation: b.rotation, visibility: "hidden" }).add(a) }, setOffset: function (a, b) { var c = this.axis, d = c.chart, e = d.inverted, f = this.isNegative, g = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1), c = c.translate(0), c = S(g - c), h = d.xAxis[0].translate(this.x) + a, k = d.plotHeight, f = { x: e ? f ? g : g - c : h, y: e ? k - h - b : f ? k - g - c : k - g, width: e ? c : b, height: e ? b : c }; if (e = this.label) e.align(this.alignOptions, null, f), f = e.alignAttr, e[!1 === this.options.crop || d.isInsidePlot(f.x, f.y) ? "show" : "hide"](!0) } }; na.prototype.buildStacks = function () { var a = this.series, b = s(this.options.reversedStacks, !0), c = a.length; if (!this.isXAxis) { for (this.usePercentage = !1; c--;) a[b ? c : a.length - c - 1].setStackedPoints(); if (this.usePercentage) for (c = 0; c < a.length; c++) a[c].setPercentStacks() } }; na.prototype.renderStackTotals = function () { var a = this.chart, b = a.renderer, c = this.stacks, d, e, f = this.stackTotalGroup; f || (this.stackTotalGroup = f = b.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add()); f.translate(a.plotLeft, a.plotTop); for (d in c) for (e in a = c[d], a) a[e].render(f) }; Q.prototype.setStackedPoints = function () { if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) { var a = this.processedXData, b = this.processedYData, c = [], d = b.length, e = this.options, f = e.threshold, g = e.stack, e = e.stacking, h = this.stackKey, k = "-" + h, l = this.negStacks, m = this.yAxis, n = m.stacks, p = m.oldStacks, q, r, s, t, u, y; for (t = 0; t < d; t++) u = a[t], y = b[t], s = this.index + "," + t, r = (q = l && y < f) ? k : h, n[r] || (n[r] = {}), n[r][u] || (p[r] && p[r][u] ? (n[r][u] = p[r][u], n[r][u].total = null) : n[r][u] = new Rb(m, m.options.stackLabels, q, u, g)), r = n[r][u], r.points[s] = [r.cum || 0], "percent" === e ? (q = q ? h : k, l && n[q] && n[q][u] ? (q = n[q][u], r.total = q.total = x(q.total, r.total) + S(y) || 0) : r.total = fa(r.total + (S(y) || 0))) : r.total = fa(r.total + (y || 0)), r.cum = (r.cum || 0) + (y || 0), r.points[s].push(r.cum), c[t] = r.cum; "percent" === e && (m.usePercentage = !0); this.stackedYData = c; m.oldStacks = {} } }; Q.prototype.setPercentStacks = function () { var a = this, b = a.stackKey, c = a.yAxis.stacks, d = a.processedXData; t([b, "-" + b], function (b) { for (var f = d.length, g, h; f--;) if (g = d[f], g = (h = c[b] && c[b][g]) && h.points[a.index + "," + f]) h = h.total ? 100 / h.total : 0, g[0] = fa(g[0] * h), g[1] = fa(g[1] * h), a.stackedYData[f] = g[1] }) }; u(Ya.prototype, { addSeries: function (a, b, c) { var d, e = this; a && (b = s(b, !0), N(e, "addSeries", { options: a }, function () { d = e.initSeries(a); e.isDirtyLegend = !0; e.linkSeries(); b && e.redraw(c) })); return d }, addAxis: function (a, b, c, d) { var e = b ? "xAxis" : "yAxis", f = this.options; new na(this, A(a, { index: this[e].length, isX: b })); f[e] = ra(f[e] || {}); f[e].push(a); s(c, !0) && this.redraw(d) }, showLoading: function (a) { var b = this, c = b.options, d = b.loadingDiv, e = c.loading, f = function () { d && D(d, { left: b.plotLeft + "px", top: b.plotTop + "px", width: b.plotWidth + "px", height: b.plotHeight + "px" }) }; d || (b.loadingDiv = d = aa(Ka, { className: "highcharts-loading" }, u(e.style, { zIndex: 10, display: V }), b.container), b.loadingSpan = aa("span", null, e.labelStyle, d), P(b, "redraw", f)); b.loadingSpan.innerHTML = a || c.lang.loading; b.loadingShown || (D(d, { opacity: 0, display: "" }), nb(d, { opacity: e.style.opacity }, { duration: e.showDuration || 0 }), b.loadingShown = !0); f() }, hideLoading: function () { var a = this.options, b = this.loadingDiv; b && nb(b, { opacity: 0 }, { duration: a.loading.hideDuration || 100, complete: function () { D(b, { display: V }) } }); this.loadingShown = !1 } }); u(Fa.prototype, { update: function (a, b, c) { var d = this, e = d.series, f = d.graphic, g, h = e.data, k = e.chart, l = e.options; b = s(b, !0); d.firePointEvent("update", { options: a }, function () { d.applyOptions(a); ea(a) && (e.getAttribs(), f && (a && a.marker && a.marker.symbol ? d.graphic = f.destroy() : f.attr(d.pointAttr[d.state || ""])), a && a.dataLabels && d.dataLabel && (d.dataLabel = d.dataLabel.destroy())); g = Da(d, h); e.updateParallelArrays(d, g); l.data[g] = d.options; e.isDirty = e.isDirtyData = !0; !e.fixedBox && e.hasCartesianSeries && (k.isDirtyBox = !0); "point" === l.legendType && k.legend.destroyItem(d); b && k.redraw(c) }) }, remove: function (a, b) { var c = this, d = c.series, e = d.points, f = d.chart, g, h = d.data; Ra(b, f); a = s(a, !0); c.firePointEvent("remove", null, function () { g = Da(c, h); h.length === e.length && e.splice(g, 1); h.splice(g, 1); d.options.data.splice(g, 1); d.updateParallelArrays(c, "splice", g, 1); c.destroy(); d.isDirty = !0; d.isDirtyData = !0; a && f.redraw() }) } }); u(Q.prototype, { addPoint: function (a, b, c, d) { var e = this.options, f = this.data, g = this.graph, h = this.area, k = this.chart, l = this.xAxis && this.xAxis.names, m = g && g.shift || 0, n = e.data, p, q = this.xData; Ra(d, k); c && t([g, h, this.graphNeg, this.areaNeg], function (a) { a && (a.shift = m + 1) }); h && (h.isArea = !0); b = s(b, !0); d = { series: this }; this.pointClass.prototype.applyOptions.apply(d, [a]); g = d.x; h = q.length; if (this.requireSorting && g < q[h - 1]) for (p = !0; h && q[h - 1] > g;) h--; this.updateParallelArrays(d, "splice", h, 0, 0); this.updateParallelArrays(d, h); l && (l[g] = d.name); n.splice(h, 0, a); p && (this.data.splice(h, 0, null), this.processData()); "point" === e.legendType && this.generatePoints(); c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(d, "shift"), n.shift())); this.isDirtyData = this.isDirty = !0; b && (this.getAttribs(), k.redraw()) }, remove: function (a, b) { var c = this, d = c.chart; a = s(a, !0); c.isRemoving || (c.isRemoving = !0, N(c, "remove", null, function () { c.destroy(); d.isDirtyLegend = d.isDirtyBox = !0; d.linkSeries(); a && d.redraw(b) })); c.isRemoving = !1 }, update: function (a, b) { var c = this, d = this.chart, e = this.userOptions, f = this.type, g = M[f].prototype, h = ["group", "markerGroup", "dataLabelsGroup"], k; t(h, function (a) { h[a] = c[a]; delete c[a] }); a = A(e, { animation: !1, index: this.index, pointStart: this.xData[0] }, { data: this.options.data }, a); this.remove(!1); for (k in g) g.hasOwnProperty(k) && (this[k] = w); u(this, M[a.type || f].prototype); t(h, function (a) { c[a] = h[a] }); this.init(d, a); d.linkSeries(); s(b, !0) && d.redraw(!1) } }); u(na.prototype, { update: function (a, b) { var c = this.chart; a = c.options[this.coll][this.options.index] = A(this.userOptions, a); this.destroy(!0); this._addedPlotLB = w; this.init(c, u(a, { events: w })); c.isDirtyBox = !0; s(b, !0) && c.redraw() }, remove: function (a) { for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;) d[e] && d[e].remove(!1); la(b.axes, this); la(b[c], this); b.options[c].splice(this.options.index, 1); t(b[c], function (a, b) { a.options.index = b }); this.destroy(); b.isDirtyBox = !0; s(a, !0) && b.redraw() }, setTitle: function (a, b) { this.update({ title: a }, b) }, setCategories: function (a, b) { this.update({ categories: a }, b) } }); var nc = ma(Q); M.line = nc; da.area = A(db, { threshold: 0 }); var Zb = ma(Q, { type: "area", getSegments: function () { var a = this, b = [], c = [], d = [], e = this.xAxis, f = this.yAxis, g = f.stacks[this.stackKey], h = {}, k, l, m = this.points, n = this.options.connectNulls, p, q; if (this.options.stacking && !this.cropped) { for (p = 0; p < m.length; p++) h[m[p].x] = m[p]; for (q in g) null !== g[q].total && d.push(+q); d.sort(function (a, b) { return a - b }); t(d, function (b) { var d = 0, m; if (!n || h[b] && null !== h[b].y) if (h[b]) c.push(h[b]); else { for (p = a.index; p <= f.series.length; p++) if (m = g[b].points[p + "," + b]) { d = m[1]; break } k = e.translate(b); l = f.toPixels(d, !0); c.push({ y: null, plotX: k, clientX: k, plotY: l, yBottom: l, onMouseOver: sa }) } }); c.length && b.push(c) } else Q.prototype.getSegments.call(this), b = this.segments; this.segments = b }, getSegmentPath: function (a) { var b = Q.prototype.getSegmentPath.call(this, a), c = [].concat(b), d, e = this.options; d = b.length; var f = this.yAxis.getThreshold(e.threshold), g; 3 === d && c.push("L", b[1], b[2]); if (e.stacking && !this.closedStacks) for (d = a.length - 1; 0 <= d; d--) g = s(a[d].yBottom, f), d < a.length - 1 && e.step && c.push(a[d + 1].plotX, g), c.push(a[d].plotX, g); else this.closeSegment(c, a, f); this.areaPath = this.areaPath.concat(c); return b }, closeSegment: function (a, b, c) { a.push("L", b[b.length - 1].plotX, c, "L", b[0].plotX, c) }, drawGraph: function () { this.areaPath = []; Q.prototype.drawGraph.apply(this); var a = this, b = this.areaPath, c = this.options, d = c.negativeColor, e = c.negativeFillColor, f = [["area", this.color, c.fillColor]]; (d || e) && f.push(["areaNeg", d, e]); t(f, function (d) { var e = d[0], f = a[e]; f ? f.animate({ d: b }) : a[e] = a.chart.renderer.path(b).attr({ fill: s(d[2], ya(d[1]).setOpacity(s(c.fillOpacity, 0.75)).get()), zIndex: 0 }).add(a.group) }) }, drawLegendSymbol: eb.drawRectangle }); M.area = Zb; da.spline = A(db); var $b = ma(Q, { type: "spline", getPointSpline: function (a, b, c) { var d = b.plotX, e = b.plotY, f = a[c - 1], g = a[c + 1], h, k, l, m; if (f && g) { a = f.plotY; l = g.plotX; var g = g.plotY, n; h = (1.5 * d + f.plotX) / 2.5; k = (1.5 * e + a) / 2.5; l = (1.5 * d + l) / 2.5; m = (1.5 * e + g) / 2.5; n = (m - k) * (l - d) / (l - h) + e - m; k += n; m += n; k > a && k > e ? (k = x(a, e), m = 2 * e - k) : k < a && k < e && (k = F(a, e), m = 2 * e - k); m > g && m > e ? (m = x(g, e), k = 2 * e - m) : m < g && m < e && (m = F(g, e), k = 2 * e - m); b.rightContX = l; b.rightContY = m } c ? (b = ["C", f.rightContX || f.plotX, f.rightContY || f.plotY, h || d, k || e, d, e], f.rightContX = f.rightContY = null) : b = ["M", d, e]; return b } }); M.spline = $b; da.areaspline = A(da.area); var Jb = Zb.prototype, oc = ma($b, { type: "areaspline", closedStacks: !0, getSegmentPath: Jb.getSegmentPath, closeSegment: Jb.closeSegment, drawGraph: Jb.drawGraph, drawLegendSymbol: eb.drawRectangle }); M.areaspline = oc; da.column = A(db, { borderColor: "#FFFFFF", borderRadius: 0, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { brightness: 0.1, shadow: !1, halo: !1 }, select: { color: "#C0C0C0", borderColor: "#000000", shadow: !1 } }, dataLabels: { align: null, verticalAlign: null, y: null }, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0 }); var Kb = ma(Q, { type: "column", pointAttrToOptions: { stroke: "borderColor", fill: "color", r: "borderRadius" }, cropShoulder: 0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function () { Q.prototype.init.apply(this, arguments); var a = this, b = a.chart; b.hasRendered && t(b.series, function (b) { b.type === a.type && (b.isDirty = !0) }) }, getColumnMetrics: function () { var a = this, b = a.options, c = a.xAxis, d = a.yAxis, e = c.reversed, f, g = {}, h, k = 0; !1 === b.grouping ? k = 1 : t(a.chart.series, function (b) { var c = b.options, e = b.yAxis; b.type === a.type && b.visible && d.len === e.len && d.pos === e.pos && (c.stacking ? (f = b.stackKey, g[f] === w && (g[f] = k++), h = g[f]) : !1 !== c.grouping && (h = k++), b.columnIndex = h) }); var c = F(S(c.transA) * (c.ordinalSlope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len), l = c * b.groupPadding, m = (c - 2 * l) / k, n = b.pointWidth, p = v(n) ? (m - n) / 2 : m * b.pointPadding, b = s(n, m - 2 * p), e = p + (l + ((e ? k - (a.columnIndex || 0) : a.columnIndex) || 0) * m - c / 2) * (e ? -1 : 1); bb && bb.chart && 0 < bb.chart.colunmMaxWidth && (c = bb.chart.colunmMaxWidth, b > c && (e = -(c / 2), b = c)); return a.columnMetrics = { width: b, offset: e } }, translate: function () { var a = this, b = a.chart, c = a.options, d = a.borderWidth = s(c.borderWidth, a.activePointCount > 0.5 * a.xAxis.len ? 0 : 1), e = a.yAxis, f = a.translatedThreshold = e.getThreshold(c.threshold), g = s(c.minPointLength, 5), h = a.getColumnMetrics(), k = h.width, l = a.barW = x(k, 1 + 2 * d), m = a.pointXOffset = h.offset, n = -(d % 2 ? 0.5 : 0), p = d % 2 ? 0.5 : 1; b.renderer.isVML && b.inverted && (p += 1); c.pointPadding && (l = La(l)); Q.prototype.translate.apply(a); t(a.points, function (c) { var d = s(c.yBottom, f), h = F(x(-999 - d, c.plotY), e.len + 999 + d), t = c.plotX + m, u = l, v = F(h, d), w; w = x(h, d) - v; S(w) < g && g && (w = g, v = y(S(v - f) > g ? d - g : f - (e.translate(c.y, 0, 1, 0, 1) <= f ? g : 0))); c.barX = t; c.pointWidth = k; c.tooltipPos = b.inverted ? [e.len - h, a.xAxis.len - t - u / 2] : [t + u / 2, h]; u = y(t + u) + n; t = y(t) + n; u -= t; d = 0.5 > S(v); w = y(v + w) + p; v = y(v) + p; w -= v; d && (v -= 1, w += 1); c.shapeType = "rect"; c.shapeArgs = { x: t, y: v, width: u, height: w } }) }, getSymbol: sa, drawLegendSymbol: eb.drawRectangle, drawGraph: sa, drawPoints: function () { var a = this, b = this.chart, c = a.options, d = b.renderer, e = c.animationLimit || 250, f, g; t(a.points, function (h) { var k = h.plotY, l = h.graphic; k === w || isNaN(k) || null === h.y ? l && (h.graphic = l.destroy()) : (f = h.shapeArgs, k = v(a.borderWidth) ? { "stroke-width": a.borderWidth } : {}, g = h.pointAttr[h.selected ? "select" : ""] || a.pointAttr[""], l ? (cb(l), l.attr(k)[b.pointCount < e ? "animate" : "attr"](A(f))) : h.graphic = d[h.shapeType](f).attr(g).attr(k).add(a.group).shadow(c.shadow, null, c.stacking && !c.borderRadius)) }) }, animate: function (a) { var b = this.yAxis, c = this.options, d = this.chart.inverted, e = {}; ca && (a ? (e.scaleY = 0.001, a = F(b.pos + b.len, x(b.pos, b.toPixels(c.threshold))), d ? e.translateX = a - b.len : e.translateY = a, this.group.attr(e)) : (e.scaleY = 1, e[d ? "translateX" : "translateY"] = b.pos, this.group.animate(e, this.options.animation), this.animate = null)) }, remove: function () { var a = this, b = a.chart; b.hasRendered && t(b.series, function (b) { b.type === a.type && (b.isDirty = !0) }); Q.prototype.remove.apply(a, arguments) } }); M.column = Kb; da.bar = A(da.column); var pc = ma(Kb, { type: "bar", inverted: !0 }); M.bar = pc; da.scatter = A(db, { lineWidth: 0, tooltip: { headerFormat: '\x3cspan style\x3d"color:{series.color}"\x3e\u25cf\x3c/span\x3e \x3cspan style\x3d"font-size: 10px;"\x3e {series.name}\x3c/span\x3e\x3cbr/\x3e', pointFormat: "x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e" }, stickyTracking: !1 }); var ac = ma(Q, { type: "scatter", sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["markerGroup", "dataLabelsGroup"], takeOrdinalPosition: !1, singularTooltips: !0, drawGraph: function () { this.options.lineWidth && Q.prototype.drawGraph.call(this) } }); M.scatter = ac; da.pie = A(db, { borderColor: "#FFFFFF", borderWidth: 1, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function () { return this.point.name } }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, states: { hover: { brightness: 0.1, shadow: !1 } }, stickyTracking: !1, tooltip: { followPointer: !0 } }); var Lb = { type: "pie", isCartesian: !1, pointClass: ma(Fa, { init: function () { Fa.prototype.init.apply(this, arguments); var a = this, b; 0 > a.y && (a.y = null); u(a, { visible: !1 !== a.visible, name: s(a.name, "Slice") }); b = function (b) { a.slice("select" === b.type) }; P(a, "select", b); P(a, "unselect", b); return a }, setVisible: function (a) { var b = this, c = b.series, d = c.chart; b.visible = b.options.visible = a = a === w ? !b.visible : a; c.options.data[Da(b, c.data)] = b.options; t(["graphic", "dataLabel", "connector", "shadowGroup"], function (c) { if (b[c]) b[c][a ? "show" : "hide"](!0) }); b.legendItem && d.legend.colorizeItem(b, a); !c.isDirty && c.options.ignoreHiddenPoint && (c.isDirty = !0, d.redraw()) }, slice: function (a, b, c) { var d = this.series; Ra(c, d.chart); s(b, !0); this.sliced = this.options.sliced = a = v(a) ? a : !this.sliced; d.options.data[Da(this, d.data)] = this.options; a = a ? this.slicedTranslation : { translateX: 0, translateY: 0 }; this.graphic.animate(a); this.shadowGroup && this.shadowGroup.animate(a) }, haloPath: function (a) { var b = this.shapeArgs, c = this.series.chart; return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.plotLeft + b.x, c.plotTop + b.y, b.r + a, b.r + a, { innerR: this.shapeArgs.r, start: b.start, end: b.end }) } }), requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color" }, singularTooltips: !0, getColor: sa, animate: function (a) { var b = this, c = b.points, d = b.startAngleRad; a || (t(c, function (a) { var c = a.graphic; a = a.shapeArgs; c && (c.attr({ r: b.center[3] / 2, start: d, end: d }), c.animate({ r: a.r, start: a.start, end: a.end }, b.options.animation)) }), b.animate = null) }, setData: function (a, b, c, d) { Q.prototype.setData.call(this, a, !1, c, d); this.processData(); this.generatePoints(); s(b, !0) && this.chart.redraw(c) }, generatePoints: function () { var a, b = 0, c, d, e, f = this.options.ignoreHiddenPoint; Q.prototype.generatePoints.call(this); c = this.points; d = c.length; for (a = 0; a < d; a++) e = c[a], b += f && !e.visible ? 0 : e.y; this.total = b; for (a = 0; a < d; a++) e = c[a], e.percentage = 0 < b ? 100 * (e.y / b) : 0, e.total = b }, translate: function (a) { this.generatePoints(); var b = 0, c = this.options, d = c.slicedOffset, e = d + c.borderWidth, f, g, h, k = c.startAngle || 0, l = this.startAngleRad = oa / 180 * (k - 90), k = (this.endAngleRad = oa / 180 * (s(c.endAngle, k + 360) - 90)) - l, m = this.points, n = c.dataLabels.distance, c = c.ignoreHiddenPoint, p, q = m.length, r; a || (this.center = a = this.getCenter()); this.getX = function (b, c) { h = W.asin(F((b - a[1]) / (a[2] / 2 + n), 1)); return a[0] + (c ? -1 : 1) * ba(h) * (a[2] / 2 + n) }; for (p = 0; p < q; p++) { r = m[p]; f = l + b * k; if (!c || r.visible) b += r.percentage / 100; g = l + b * k; r.shapeType = "arc"; r.shapeArgs = { x: a[0], y: a[1], r: a[2] / 2, innerR: a[3] / 2, start: y(1E3 * f) / 1E3, end: y(1E3 * g) / 1E3 }; h = (g + f) / 2; h > 1.5 * oa ? h -= 2 * oa : h < -oa / 2 && (h += 2 * oa); r.slicedTranslation = { translateX: y(ba(h) * d), translateY: y(ga(h) * d) }; f = ba(h) * a[2] / 2; g = ga(h) * a[2] / 2; r.tooltipPos = [a[0] + 0.7 * f, a[1] + 0.7 * g]; r.half = h < -oa / 2 || h > oa / 2 ? 1 : 0; r.angle = h; e = F(e, n / 2); r.labelPos = [a[0] + f + ba(h) * n, a[1] + g + ga(h) * n, a[0] + f + ba(h) * e, a[1] + g + ga(h) * e, a[0] + f, a[1] + g, 0 > n ? "center" : r.half ? "right" : "left", h] } }, drawGraph: null, drawPoints: function () { var a = this, b = a.chart.renderer, c, d, e = a.options.shadow, f, g; e && !a.shadowGroup && (a.shadowGroup = b.g("shadow").add(a.group)); t(a.points, function (h) { d = h.graphic; g = h.shapeArgs; f = h.shadowGroup; e && !f && (f = h.shadowGroup = b.g("shadow").add(a.shadowGroup)); c = h.sliced ? h.slicedTranslation : { translateX: 0, translateY: 0 }; f && f.attr(c); d ? d.animate(u(g, c)) : h.graphic = d = b[h.shapeType](g).setRadialReference(a.center).attr(h.pointAttr[h.selected ? "select" : ""]).attr({ "stroke-linejoin": "round" }).attr(c).add(a.group).shadow(e, f); void 0 !== h.visible && h.setVisible(h.visible) }) }, sortByAngle: function (a, b) { a.sort(function (a, d) { return void 0 !== a.angle && (d.angle - a.angle) * b }) }, drawLegendSymbol: eb.drawRectangle, getCenter: mc.getCenter, getSymbol: sa }, Lb = ma(Q, Lb); M.pie = Lb; Q.prototype.drawDataLabels = function () { var a = this, b = a.options, c = b.cursor, d = b.dataLabels, e = a.points, f, g, h, k; if (d.enabled || a._hasPointLabels) a.dlProcessOptions && a.dlProcessOptions(d), k = a.plotGroup("dataLabelsGroup", "data-labels", d.defer ? "hidden" : "visible", d.zIndex || 6), !a.hasRendered && s(d.defer, !0) && (k.attr({ opacity: 0 }), P(a, "afterAnimate", function () { a.visible && k.show(); k[b.animation ? "animate" : "attr"]({ opacity: 1 }, { duration: 200 }) })), g = d, t(e, function (b) { var e, n = b.dataLabel, p, q, r = b.connector, t = !0; f = b.options && b.options.dataLabels; e = s(f && f.enabled, g.enabled); if (n && !e) b.dataLabel = n.destroy(); else if (e) { d = A(g, f); e = d.rotation; p = b.getLabelConfig(); h = d.format ? Ja(d.format, p) : d.formatter.call(p, d); d.style.color = s(d.color, d.style.color, a.color, "black"); if (n) v(h) ? (n.attr({ text: h }), t = !1) : (b.dataLabel = n = n.destroy(), r && (b.connector = r.destroy())); else if (v(h)) { n = { fill: d.backgroundColor, stroke: d.borderColor, "stroke-width": d.borderWidth, r: d.borderRadius || 0, rotation: e, padding: d.padding, zIndex: 1 }; for (q in n) n[q] === w && delete n[q]; n = b.dataLabel = a.chart.renderer[e ? "text" : "label"](h, 0, -999, null, null, null, d.useHTML).attr(n).css(u(d.style, c && { cursor: c })).add(k).shadow(d.shadow) } n && a.alignDataLabel(b, n, d, null, t) } }) }; Q.prototype.alignDataLabel = function (a, b, c, d, e) { var f = this.chart, g = f.inverted, h = s(a.plotX, -999), k = s(a.plotY, -999), l = b.getBBox(); if (a = this.visible && (a.series.forceDL || f.isInsidePlot(h, y(k), g) || d && f.isInsidePlot(h, g ? d.x + 1 : d.y + d.height - 1, g))) d = u({ x: g ? f.plotWidth - k : h, y: y(g ? f.plotHeight - h : k), width: 0, height: 0 }, d), u(c, { width: l.width, height: l.height }), c.rotation ? b[e ? "attr" : "animate"]({ x: d.x + c.x + d.width / 2, y: d.y + c.y + d.height / 2 }).attr({ align: c.align }) : (b.align(c, null, d), g = b.alignAttr, "justify" === s(c.overflow, "justify") ? this.justifyDataLabel(b, c, g, l, d, e) : s(c.crop, !0) && (a = f.isInsidePlot(g.x, g.y) && f.isInsidePlot(g.x + l.width, g.y + l.height))); a || (b.attr({ y: -999 }), b.placed = !1) }; Q.prototype.justifyDataLabel = function (a, b, c, d, e, f) { var g = this.chart, h = b.align, k = b.verticalAlign, l, m; l = c.x; 0 > l && ("right" === h ? b.align = "left" : b.x = -l, m = !0); l = c.x + d.width; l > g.plotWidth && ("left" === h ? b.align = "right" : b.x = g.plotWidth - l, m = !0); l = c.y; 0 > l && ("bottom" === k ? b.verticalAlign = "top" : b.y = -l, m = !0); l = c.y + d.height; l > g.plotHeight && ("top" === k ? b.verticalAlign = "bottom" : b.y = g.plotHeight - l, m = !0); m && (a.placed = !f, a.align(b, null, e)) }; M.pie && (M.pie.prototype.drawDataLabels = function () { var a = this, b = a.data, c, d = a.chart, e = a.options.dataLabels, f = s(e.connectorPadding, 10), g = s(e.connectorWidth, 1), h = d.plotWidth, k = d.plotHeight, l, m, n = s(e.softConnector, !0), p = e.distance, q = a.center, r = q[2] / 2, u = q[1], v = 0 < p, w, z, A, C = [[], []], E, D, N, M, B, T = [0, 0, 0, 0], P = function (a, b) { return b.y - a.y }; if (a.visible && (e.enabled || a._hasPointLabels)) { Q.prototype.drawDataLabels.apply(a); t(b, function (a) { a.dataLabel && a.visible && C[a.half].push(a) }); for (M = 2; M--;) { var I = [], R = [], K = C[M], O = K.length, J; if (O) { a.sortByAngle(K, M - 0.5); for (B = b = 0; !b && K[B];) b = K[B] && K[B].dataLabel && (K[B].dataLabel.getBBox().height || 21), B++; if (0 < p) { z = F(u + r + p, d.plotHeight); for (B = x(0, u - r - p) ; B <= z; B += b) I.push(B); z = I.length; if (O > z) { c = [].concat(K); c.sort(P); for (B = O; B--;) c[B].rank = B; for (B = O; B--;) K[B].rank >= z && K.splice(B, 1); O = K.length } for (B = 0; B < O; B++) { c = K[B]; A = c.labelPos; c = 9999; var V, U; for (U = 0; U < z; U++) V = S(I[U] - A[1]), V < c && (c = V, J = U); if (J < B && null !== I[B]) J = B; else for (z < O - B + J && null !== I[B] && (J = z - O + B) ; null === I[J];) J++; R.push({ i: J, y: I[J] }); I[J] = null } R.sort(P) } for (B = 0; B < O; B++) { c = K[B]; A = c.labelPos; w = c.dataLabel; N = !1 === c.visible ? "hidden" : "visible"; c = A[1]; if (0 < p) { if (z = R.pop(), J = z.i, D = z.y, c > D && null !== I[J + 1] || c < D && null !== I[J - 1]) D = F(x(0, c), d.plotHeight) } else D = c; E = e.justify ? q[0] + (M ? -1 : 1) * (r + p) : a.getX(D === u - r - p || D === u + r + p ? c : D, M); w._attr = { visibility: N, align: A[6] }; w._pos = { x: E + e.x + ({ left: f, right: -f }[A[6]] || 0), y: D + e.y - 10 }; w.connX = E; w.connY = D; null === this.options.size && (z = w.width, E - z < f ? T[3] = x(y(z - E + f), T[3]) : E + z > h - f && (T[1] = x(y(E + z - h + f), T[1])), 0 > D - b / 2 ? T[0] = x(y(-D + b / 2), T[0]) : D + b / 2 > k && (T[2] = x(y(D + b / 2 - k), T[2]))) } } } if (0 === Ba(T) || this.verifyDataLabelOverflow(T)) this.placeDataLabels(), v && g && t(this.points, function (b) { l = b.connector; A = b.labelPos; (w = b.dataLabel) && w._pos ? (N = w._attr.visibility, E = w.connX, D = w.connY, m = n ? ["M", E + ("left" === A[6] ? 5 : -5), D, "C", E, D, 2 * A[2] - A[4], 2 * A[3] - A[5], A[2], A[3], "L", A[4], A[5]] : ["M", E + ("left" === A[6] ? 5 : -5), D, "L", A[2], A[3], "L", A[4], A[5]], l ? (l.animate({ d: m }), l.attr("visibility", N)) : b.connector = l = a.chart.renderer.path(m).attr({ "stroke-width": g, stroke: e.connectorColor || b.color || "#606060", visibility: N }).add(a.dataLabelsGroup)) : l && (b.connector = l.destroy()) }) } }, M.pie.prototype.placeDataLabels = function () { t(this.points, function (a) { a = a.dataLabel; var b; a && ((b = a._pos) ? (a.attr(a._attr), a[a.moved ? "animate" : "attr"](b), a.moved = !0) : a && a.attr({ y: -999 })) }) }, M.pie.prototype.alignDataLabel = sa, M.pie.prototype.verifyDataLabelOverflow = function (a) { var b = this.center, c = this.options, d = c.center, e = c = c.minSize || 80, f; null !== d[0] ? e = x(b[2] - x(a[1], a[3]), c) : (e = x(b[2] - a[1] - a[3], c), b[0] += (a[3] - a[1]) / 2); null !== d[1] ? e = x(F(e, b[2] - x(a[0], a[2])), c) : (e = x(F(e, b[2] - a[0] - a[2]), c), b[1] += (a[0] - a[2]) / 2); e < b[2] ? (b[2] = e, this.translate(b), t(this.points, function (a) { a.dataLabel && (a.dataLabel._pos = null) }), this.drawDataLabels && this.drawDataLabels()) : f = !0; return f }); M.column && (M.column.prototype.alignDataLabel = function (a, b, c, d, e) { var f = this.chart, g = f.inverted, h = a.dlBox || a.shapeArgs, k = a.below || a.plotY > s(this.translatedThreshold, f.plotSizeY), l = s(c.inside, !!this.options.stacking); h && (d = A(h), g && (d = { x: f.plotWidth - d.y - d.height, y: f.plotHeight - d.x - d.width, width: d.height, height: d.width }), l || (g ? (d.x += k ? 0 : d.width, d.width = 0) : (d.y += k ? d.height : 0, d.height = 0))); c.align = s(c.align, !g || l ? "center" : k ? "right" : "left"); c.verticalAlign = s(c.verticalAlign, g || l ? "middle" : k ? "top" : "bottom"); Q.prototype.alignDataLabel.call(this, a, b, c, d, e) }); var qb = J.TrackerMixin = { drawTrackerPoint: function () { var a = this, b = a.chart, c = b.pointer, d = a.options.cursor, e = d && { cursor: d }, f = function (c) { var d = c.target, e; if (b.hoverSeries !== a) a.onMouseOver(); for (; d && !e;) e = d.point, d = d.parentNode; if (e !== w && e !== b.hoverPoint) e.onMouseOver(c) }; t(a.points, function (a) { a.graphic && (a.graphic.element.point = a); a.dataLabel && (a.dataLabel.element.point = a) }); a._hasTracking || (t(a.trackerGroups, function (b) { if (a[b] && (a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function (a) { c.onTrackerMouseOut(a) }).css(e), $a)) a[b].on("touchstart", f) }), a._hasTracking = !0) }, drawTrackerGraph: function () { var a = this, b = a.options, c = b.trackByArea, d = [].concat(c ? a.areaPath : a.graphPath), e = d.length, f = a.chart, g = f.pointer, h = f.renderer, k = f.options.tooltip.snap, l = a.tracker, m = b.cursor, n = m && { cursor: m }, m = a.singlePoints, p, q = function () { if (f.hoverSeries !== a) a.onMouseOver() }, r = "rgba(192,192,192," + (ca ? 1E-4 : 0.002) + ")"; if (e && !c) for (p = e + 1; p--;) "M" === d[p] && d.splice(p + 1, 0, d[p + 1] - k, d[p + 2], "L"), (p && "M" === d[p] || p === e) && d.splice(p, 0, "L", d[p - 2] + k, d[p - 1]); for (p = 0; p < m.length; p++) e = m[p], d.push("M", e.plotX - k, e.plotY, "L", e.plotX + k, e.plotY); l ? l.attr({ d: d }) : (a.tracker = h.path(d).attr({ "stroke-linejoin": "round", visibility: a.visible ? "visible" : "hidden", stroke: r, fill: c ? r : V, "stroke-width": b.lineWidth + (c ? 0 : 2 * k), zIndex: 2 }).add(a.group), t([a.tracker, a.markerGroup], function (a) { a.addClass("highcharts-tracker").on("mouseover", q).on("mouseout", function (a) { g.onTrackerMouseOut(a) }).css(n); if ($a) a.on("touchstart", q) })) } }; M.column && (Kb.prototype.drawTracker = qb.drawTrackerPoint); M.pie && (M.pie.prototype.drawTracker = qb.drawTrackerPoint); M.scatter && (ac.prototype.drawTracker = qb.drawTrackerPoint); u(pb.prototype, { setItemEvents: function (a, b, c, d, e) { var f = this; (c ? b : a.legendGroup).on("mouseover", function () { a.setState("hover"); b.css(f.options.itemHoverStyle) }).on("mouseout", function () { b.css(a.visible ? d : e); a.setState() }).on("click", function (b) { var c = function () { a.setVisible() }; b = { browserEvent: b }; a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : N(a, "legendItemClick", b, c) }) }, createCheckboxForItem: function (a) { a.checkbox = aa("input", { type: "checkbox", checked: a.selected, defaultChecked: a.selected }, this.options.itemCheckboxStyle, this.chart.container); P(a.checkbox, "click", function (b) { N(a, "checkboxClick", { checked: b.target.checked }, function () { a.select() }) }) } }); K.legend.itemStyle.cursor = "pointer"; u(Ya.prototype, { showResetZoom: function () { var a = this, b = K.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo ? null : "plotBox"; this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function () { a.zoomOut() }, d, e && e.hover).attr({ align: c.position.align, title: b.resetZoomTitle }).add().align(c.position, !1, f) }, zoomOut: function () { var a = this; N(a, "selection", { resetSelection: !0 }, function () { a.zoom() }) }, zoom: function (a) { var b, c = this.pointer, d = !1, e; !a || a.resetSelection ? t(this.axes, function (a) { b = a.zoom() }) : t(a.xAxis.concat(a.yAxis), function (a) { var e = a.axis, h = e.isXAxis; if (c[h ? "zoomX" : "zoomY"] || c[h ? "pinchX" : "pinchY"]) b = e.zoom(a.min, a.max), e.displayBtn && (d = !0) }); e = this.resetZoomButton; d && !e ? this.showResetZoom() : !d && ea(e) && (this.resetZoomButton = e.destroy()); b && this.redraw(s(this.options.chart.animation, a && a.animation, 100 > this.pointCount)) }, pan: function (a, b) { var c = this, d = c.hoverPoints, e; d && t(d, function (a) { a.setState() }); t("xy" === b ? [1, 0] : [1], function (b) { var d = a[b ? "chartX" : "chartY"], h = c[b ? "xAxis" : "yAxis"][0], k = c[b ? "mouseDownX" : "mouseDownY"], l = (h.pointRange || 0) / 2, m = h.getExtremes(), n = h.toValue(k - d, !0) + l, k = h.toValue(k + c[b ? "plotWidth" : "plotHeight"] - d, !0) - l; h.series.length && n > F(m.dataMin, m.min) && k < x(m.dataMax, m.max) && (h.setExtremes(n, k, !1, !1, { trigger: "pan" }), e = !0); c[b ? "mouseDownX" : "mouseDownY"] = d }); e && c.redraw(!1); D(c.container, { cursor: "move" }) } }); u(Fa.prototype, { select: function (a, b) { var c = this, d = c.series, e = d.chart; a = s(a, !c.selected); c.firePointEvent(a ? "select" : "unselect", { accumulate: b }, function () { c.selected = c.options.selected = a; d.options.data[Da(c, d.data)] = c.options; c.setState(a && "select"); b || t(e.getSelectedPoints(), function (a) { a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[Da(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect")) }) }) }, onMouseOver: function (a) { var b = this.series, c = b.chart, d = c.tooltip, e = c.hoverPoint; if (e && e !== this) e.onMouseOut(); this.firePointEvent("mouseOver"); !d || d.shared && !b.noSharedTooltip || d.refresh(this, a); this.setState("hover"); c.hoverPoint = this }, onMouseOut: function () { var a = this.series.chart, b = a.hoverPoints; this.firePointEvent("mouseOut"); if (!b || -1 === Da(this, b)) if (this.setState(), window.addEventListener || a.userOptions.chart && !a.userOptions.chart.isClearHoverPoint) a.hoverPoint = null }, importEvents: function () { if (!this.hasImportedEvents) { var a = A(this.series.options.point, this.options).events, b; this.events = a; for (b in a) P(this, b, a[b]); this.hasImportedEvents = !0 } }, setState: function (a, b) { var c = this.plotX, d = this.plotY, e = this.series, f = e.options.states, g = da[e.type].marker && e.options.marker, h = g && !g.enabled, k = g && g.states[a], l = k && !1 === k.enabled, m = e.stateMarkerGraphic, n = this.marker || {}, p = e.chart, q = e.halo, r; a = a || ""; r = this.pointAttr[a] || e.pointAttr[a]; if (!(a === this.state && !b || this.selected && "select" !== a || f[a] && !1 === f[a].enabled || a && (l || h && !1 === k.enabled) || a && n.states && n.states[a] && !1 === n.states[a].enabled)) { if (this.graphic) g = g && this.graphic.symbolName && r.r, this.graphic.attr(A(r, g ? { x: c - g, y: d - g, width: 2 * g, height: 2 * g } : {})), m && m.hide(); else { if (a && k) if (g = k.radius, n = n.symbol || e.symbol, m && m.currentSymbol !== n && (m = m.destroy()), m) m[b ? "animate" : "attr"]({ x: c - g, y: d - g }); else n && (e.stateMarkerGraphic = m = p.renderer.symbol(n, c - g, d - g, 2 * g, 2 * g).attr(r).add(e.markerGroup), m.currentSymbol = n); if (m) m[a && p.isInsidePlot(c, d, p.inverted) ? "show" : "hide"]() } (c = f[a] && f[a].halo) && c.size ? (q || (e.halo = q = p.renderer.path().add(e.seriesGroup)), q.attr(u({ fill: ya(this.color || e.color).setOpacity(c.opacity).get() }, c.attributes))[b ? "animate" : "attr"]({ d: this.haloPath(c.size) })) : q && q.attr({ d: [] }); this.state = a } }, haloPath: function (a) { var b = this.series, c = b.chart, d = b.getPlotBox(), e = c.inverted; return c.renderer.symbols.circle(d.translateX + (e ? b.yAxis.len - this.plotY : this.plotX) - a, d.translateY + (e ? b.xAxis.len - this.plotX : this.plotY) - a, 2 * a, 2 * a) } }); u(Q.prototype, { onMouseOver: function () { var a = this.chart, b = a.hoverSeries; if (b && b !== this) b.onMouseOut(); this.options.events.mouseOver && N(this, "mouseOver"); this.setState("hover"); a.hoverSeries = this }, onMouseOut: function () { var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint; if (d) d.onMouseOut(); this && a.events.mouseOut && N(this, "mouseOut"); !c || a.stickyTracking || c.shared && !this.noSharedTooltip || c.hide(); this.setState(); b.hoverSeries = null }, setState: function (a) { var b = this.options, c = this.graph, d = this.graphNeg, e = b.states, b = b.lineWidth; a = a || ""; this.state !== a && (this.state = a, e[a] && !1 === e[a].enabled || (a && (b = e[a].lineWidth || b + (e[a].lineWidthPlus || 0)), c && !c.dashstyle && (a = { "stroke-width": b }, c.attr(a), d && d.attr(a)))) }, setVisible: function (a, b) { var c = this, d = c.chart, e = c.legendItem, f, g = d.options.chart.ignoreHiddenSeries, h = c.visible; f = (c.visible = a = c.userOptions.visible = a === w ? !h : a) ? "show" : "hide"; t(["group", "dataLabelsGroup", "markerGroup", "tracker"], function (a) { if (c[a]) c[a][f]() }); if (d.hoverSeries === c) c.onMouseOut(); e && d.legend.colorizeItem(c, a); c.isDirty = !0; c.options.stacking && t(d.series, function (a) { a.options.stacking && a.visible && (a.isDirty = !0) }); t(c.linkedSeries, function (b) { b.setVisible(a, !1) }); g && (d.isDirtyBox = !0); !1 !== b && d.redraw(); N(c, f) }, setTooltipPoints: function (a) { var b = [], c, d, e = this.xAxis, f = e && e.getExtremes(), g = e ? e.tooltipLen || e.len : this.chart.plotSizeX, h, k, l = []; if (!1 !== this.options.enableMouseTracking && !this.singularTooltips) { a && (this.tooltipPoints = null); t(this.segments || this.points, function (a) { b = b.concat(a) }); e && e.reversed && (b = b.reverse()); this.orderTooltipPoints && this.orderTooltipPoints(b); a = b.length; for (k = 0; k < a; k++) if (e = b[k], c = e.x, c >= f.min && c <= f.max) for (h = b[k + 1], c = d === w ? 0 : d + 1, d = b[k + 1] ? F(x(0, U((e.clientX + (h ? h.wrappedClientX || h.clientX : g)) / 2)), g) : g; 0 <= c && c <= d;) l[c++] = e; this.tooltipPoints = l } }, show: function () { this.setVisible(!0) }, hide: function () { this.setVisible(!1) }, select: function (a) { this.selected = a = a === w ? !this.selected : a; this.checkbox && (this.checkbox.checked = a); N(this, a ? "select" : "unselect") }, drawTracker: qb.drawTrackerGraph }); u(J, { Axis: na, Chart: Ya, Color: ya, Point: Fa, Tick: Ta, Renderer: Za, Series: Q, SVGElement: O, SVGRenderer: ta, arrayMin: Oa, arrayMax: Ba, charts: X, dateFormat: fb, format: Ja, pathAnim: Ab, getOptions: function () { return K }, hasBidiBug: bc, isTouchDevice: Tb, numberFormat: Ha, seriesTypes: M, setOptions: function (a) { K = A(!0, K, a); Mb(); return K }, addEvent: P, removeEvent: Y, createElement: aa, discardElement: Qa, css: D, each: t, extend: u, map: Va, merge: A, pick: s, splat: ra, extendClass: ma, pInt: C, wrap: Na, svg: ca, canvas: ha, vml: !ca && !ha, product: "Highcharts", version: "4.0.3" }) })();